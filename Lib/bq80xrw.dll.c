/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

void sub_10001000();
FARPROC __cdecl sub_10001010(LPCSTR lpProcName, _DWORD *a2);
int __cdecl sub_10001100(int a1, int a2, int a3, int a4);
int __cdecl sub_10001160(int a1);
int __cdecl sub_100011B0(int a1);
int __cdecl sub_10001200(int a1, int a2);
int __cdecl sub_10001250(int a1, int a2);
int __cdecl sub_100012A0(int a1, int a2, int a3, int a4);
int __cdecl sub_10001300(int a1, unsigned __int16 a2, int a3, unsigned __int16 a4, int a5);
int __cdecl sub_10001360(char a1, char a2);
int __cdecl sub_10001430(__int16 a1, char *a2, __int16 a3);
int __cdecl sub_10001490(unsigned __int16 a1, int a2, __int16 a3);
int sub_100015F0();
int __cdecl AA_Control(int a1, int a2);
int sub_10001940();
int __cdecl OpenDeviceA(const char *a1);
int CloseDeviceA();
int __cdecl WritePacket(int a1, char *a2, _DWORD *a3);
int __cdecl ReadPacket(int a1, char *a2, _DWORD *a3);
BOOL __cdecl sub_10001A60(char *a1);
int __cdecl sub_10001AA0(char *a1, int a2);
int sub_10001C10();
int __cdecl sub_10001D40(__int16 a1, _WORD *a2, __int16 a3);
int __cdecl sub_10001E70(_BYTE *a1, char a2, unsigned __int8 a3, int a4);
unsigned __int8 __cdecl sub_10001F00(int a1);
char __cdecl sub_10001F70(unsigned __int8 *a1);
bool __cdecl sub_10001FF0(int a1);
int __cdecl ReadSMBusWord(__int16 a1, _WORD *a2, __int16 a3);
int __cdecl WriteSMBusWord(__int16 a1, __int16 a2, __int16 a3);
int __cdecl WriteSMBusBlock(unsigned __int8 a1, int a2, __int16 a3, __int16 a4);
int __cdecl ReadSMBusBlock(__int16 a1, int a2, __int16 *a3, __int16 a4);
int __cdecl sub_10002570(int a1, _DWORD *a2, _BYTE *a3, size_t Size);
int __cdecl GetAllBoards(int a1, _DWORD *a2, _BYTE *a3, size_t Size);
int __cdecl I2CPower(__int16 a1);
int __cdecl sub_10002970(__int16 a1, __int16 a2, __int16 a3, _WORD *a4);
int __cdecl sub_10002BD0(int a1);
int __cdecl WriteSMBusCmd(unsigned __int8 a1, __int16 a2);
int __cdecl sub_10002C70(unsigned __int8 a1, __int16 a2);
int CheckForError();
int sub_10002D20();
int __cdecl sub_10002D90(char a1, char a2);
int __cdecl sub_10002E00(int a1, unsigned __int8 a2, __int16 a3);
int __cdecl sub_10002FF0(int a1, int a2, unsigned __int8 a3, _WORD *a4);
int __cdecl HDQ8ReadByte(__int16 a1, _WORD *a2);
int __cdecl HDQ8WriteByte(__int16 a1, __int16 a2);
__int16 __cdecl sub_100031E0(int a1, __int16 a2, _WORD *a3);
int __cdecl Delay(int a1);
int __cdecl ReadI2CBusBlockNcmd(int a1, __int16 *a2, __int16 a3);
int __cdecl sub_10003500(_BYTE *a1);
int __cdecl I2CReadBlock(__int16 a1, int a2, __int16 a3, __int16 a4);
int __cdecl I2CWriteBlock(__int16 a1, int a2, __int16 a3, __int16 a4);
int __cdecl I2CLtReadBlock(__int16 a1, __int16 a2, int a3, __int16 a4);
int __cdecl I2CLtWriteBlock(__int16 a1, __int16 a2, int a3, __int16 a4);
int I2CLtStop();
int __cdecl sub_10003C40(_DWORD *a1, _DWORD *a2);
int __cdecl I2CLtSetTiming(char a1, char a2, char a3, char a4, __int16 a5);
int __cdecl GetAdapterFWVersion(char *Buffer); // idb
int __cdecl GPIOWrite(__int16 a1, __int16 a2);
int __cdecl GPIORead(char a1, _WORD *a2);
int __cdecl sub_100040A0(char a1, char *a2, char *a3);
int __cdecl GetEV2300Name(_BYTE *a1, _DWORD *a2);
int __cdecl SetEV2300Name(int a1, int a2);
int __cdecl SetTUSBCharacteristic1(__int16 a1, __int16 a2);
int __cdecl GPIOSetup(int a1, __int16 a2);
int __cdecl GPIOWriteRead(int a1, __int16 *a2);
bool sub_10004A60();
int __cdecl SetPinVoltage(__int16 a1, __int16 a2);
int __cdecl SetVVODVoltage(__int16 a1, __int16 a2);
int __cdecl GetVVODVoltage(char a1, _WORD *a2);
int __cdecl sub_10004E10(__int16 a1, int a2, __int16 a3);
int __cdecl sub_10004E80(__int16 a1, int a2, __int16 a3);
int __cdecl HDQ8ReadBlock(__int16 a1, int a2, __int16 a3);
int __cdecl HDQ8WriteBlock(__int16 a1, int a2, __int16 a3);
int HDQSendBreak();
int __cdecl SetEV2400CommClkSpeed(__int16 a1, __int16 a2);
int __cdecl UseAardvarkSPI(int a1);
int __cdecl SPI16ReadBlock(unsigned __int8 a1, int a2, unsigned __int8 a3);
int __cdecl SPI16WriteBlock(unsigned __int8 a1, char *a2, unsigned __int8 a3);
int __cdecl SPIConfigure(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl SPIReadConfiguration(_WORD *a1, _WORD *a2, _DWORD *a3, _WORD *a4);
int __cdecl GetBoardType(__int16 *a1, int a2);
int __cdecl SetVoutWithTimeout(char a1, char a2, char a3, char a4);
int __cdecl SetPWMConfig(__int16 a1);
FILE *__cdecl sub_10005B90(int a1, const char *a2, __int16 a3, __int16 a4, unsigned __int8 *a5);
int __cdecl StartCommLogging(char *Source); // idb
void StopCommLogging();
int __cdecl OpenDeviceBySerial_(char *a1);
int __cdecl GetSerialNumberString_(char *a1, __int16 a2);
BOOL sub_10005EC0();
// long double __cdecl ldexpl(long double X, int Y);
unsigned int __cdecl sub_10005F10(int a1);
int __cdecl sub_10005FA0(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_10006010(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_10006070(char *Buffer); // idb
int __cdecl sub_100061B0(char *Buffer); // idb
int __cdecl sub_100063D0(FILE *Stream, char *); // idb
int __cdecl sub_10006570(FILE *Stream, int); // idb
int __cdecl sub_100066C0(char *FileName, int); // idb
int __cdecl sub_100067F0(_DWORD *a1, int a2);
int __cdecl sub_10006850(__int16 a1, int a2);
int __cdecl sub_100069F0(unsigned __int16 *a1);
int __cdecl sub_10006AE0(FILE *Stream, int); // idb
int __cdecl sub_10006C90(FILE *Stream, int); // idb
int __cdecl sub_10006D10(char *FileName, unsigned __int16 *a2);
_BYTE *__cdecl sub_10006E10(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_10006E90(char a1);
int __cdecl sub_10006EF0(char *a1, unsigned __int8 a2);
double __cdecl sub_10006F60(double a1, int a2);
_DWORD *__thiscall sub_10006FD0(_DWORD *this, void *Src, size_t Size, char a4);
char __thiscall sub_10007020(int this, char a2, _DWORD *a3);
char __thiscall sub_10007090(_DWORD *this, char a2);
_BYTE *__thiscall sub_100070B0(_BYTE *this);
void __thiscall sub_100070E0(void **this);
bool __thiscall sub_10007110(FILE **this);
char __thiscall sub_10007140(FILE **this, char *FileName, char *Mode);
BOOL __thiscall sub_100071B0(FILE **this);
int __thiscall sub_100071E0(int this);
int __thiscall sub_10007260(void *this, int a2, int a3);
size_t __thiscall sub_100072C0(size_t this);
int __cdecl sub_100074C0(int a1, unsigned __int8 a2, unsigned __int8 a3);
void __cdecl StartAddress();
bool __cdecl sub_100076F0(unsigned int a1, unsigned __int8 a2);
bool __cdecl sub_10007990(unsigned int a1, unsigned __int8 a2);
bool __cdecl sub_10007C30(__int16 a1, unsigned int a2, unsigned __int8 a3);
char __cdecl sub_10007EB0(int a1, int a2, unsigned int a3, __int16 a4);
bool __cdecl sub_10007F20(unsigned int a1, unsigned int a2, __int16 a3);
char __cdecl sub_10007F60(char a1, char a2, int a3, int a4, __int16 a5);
char __cdecl sub_100080A0(int a1, int a2, int a3, char a4);
char __cdecl sub_10008440(int a1, _BYTE *a2, int a3, unsigned __int16 a4, unsigned __int8 a5);
int __cdecl sub_10008780(int a1, __int16 a2);
char sub_100088B0();
int __cdecl sub_10008BA0(char *a1, int a2, unsigned __int16 a3, int a4, int a5, int a6, __int16 a7);
int __cdecl sub_10009030(char *FileName, __int16); // idb
int __cdecl I2CProgram_C816senc(char *FileName); // idb
bool __cdecl sub_10009420(int a1);
char __cdecl sub_10009450(int a1);
char __cdecl sub_100094B0(int a1, char a2, __int16 a3, int a4, int a5);
int __cdecl sub_10009560(_BYTE *a1, char a2, char a3, __int16 a4, _DWORD *a5);
int __cdecl sub_100095E0(_BYTE *a1, char a2, char a3, _DWORD *a4);
int __cdecl sub_10009630(_BYTE *a1, char a2, _DWORD *a3);
int __cdecl sub_10009660(_BYTE *a1, char a2, char a3, unsigned __int8 a4, _BYTE *a5, _DWORD *a6);
int __cdecl sub_100096F0(_BYTE *a1, char a2, char a3, int a4, _DWORD *a5);
void __cdecl sub_10009740();
bool __cdecl sub_10009930(char a1, __int16 a2, int a3, int a4);
char __cdecl sub_100099A0(unsigned int a1, __int16 a2);
bool __cdecl sub_10009A60(unsigned int a1, char a2);
bool __cdecl sub_10009B10(unsigned int a1, char a2);
bool __cdecl sub_10009BC0(__int16 a1, unsigned int a2, char a3);
char __cdecl sub_10009C70(int a1, int a2, unsigned int a3, __int16 a4);
bool __cdecl sub_10009CE0(unsigned int a1, unsigned int a2, __int16 a3);
char __cdecl sub_10009D20(int a1, int a2);
char __cdecl sub_10009D90(int a1, int a2, int a3, char a4);
char __cdecl sub_1000A0B0(int a1, _BYTE *a2, int a3, unsigned __int16 a4, char a5);
int __cdecl sub_1000A1E0(int a1, __int16 a2);
char sub_1000A300();
int __cdecl ProgramFlash(char *a1, int a2, unsigned __int16 a3, int a4, int a5, int a6, __int16 a7);
int __cdecl sub_1000A3B0(char *a1, int a2, unsigned __int16 a3, int a4, int a5, int a6, __int16 a7);
_DWORD *__cdecl sub_1000A850(_DWORD *a1, unsigned __int16 a2);
int __cdecl ProgSrecFromFile(char *FileName); // idb
int __cdecl ProgramSrecWithCfg(char *FileName, char *, char *); // idb
int __cdecl sub_1000AC50(char *FileName, char *, char *); // idb
int __cdecl BlastPackets(char *FileName); // idb
int __cdecl ReadFlash(int a1, int a2, void *a3, _DWORD *a4, int *a5, _DWORD *a6, __int16 a7);
int __cdecl sub_1000B230(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl SetOcxCharacteristic(char a1, char a2);
int __cdecl sub_1000B310(char a1, char a2);
__int16 __cdecl sub_1000B340(int a1, int a2);
void __cdecl sub_1000B390();
int sub_1000B960();
int __cdecl sub_1000BCA0(int a1);
bool __cdecl sub_1000BD70(int a1, int a2, __int16 a3, unsigned __int8 a4);
char __cdecl sub_1000BF80(__int16 a1, __int16 a2, __int16 a3);
char __cdecl sub_1000C1F0(__int16 a1, __int16 a2, __int16 a3);
char __cdecl sub_1000C300(__int16 a1, __int16 a2);
char __cdecl sub_1000C540(__int16 a1, __int16 a2);
int __cdecl sub_1000C670(__int16 a1, unsigned int a2, unsigned int a3, unsigned __int8 a4, void *a5, int *a6);
int __cdecl CompareSrecWithCfg(char *FileName, char *, char *); // idb
int __cdecl ReadC816Senc(char *FileName, __int16); // idb
int __cdecl sub_1000D0E0(char *a1);
int __cdecl sub_1000D140(char **a1);
int __cdecl sub_1000D180(int a1);
int __cdecl sub_1000D1B0(int a1);
int __cdecl sub_1000D220(char *a1, _BYTE *a2);
int __cdecl sub_1000D2B0(char *a1, int *a2);
int __cdecl sub_1000D330(char *a1, _BYTE *a2, int *a3);
int __cdecl sub_1000D4A0(FILE *Stream, int); // idb
int __cdecl sub_1000D820(char *FileName, char *, char *, int); // idb
int sub_1000E534();
void *sub_1000E5F8();
// int __cdecl _clean_type_info_names_internal(_DWORD); weak
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
int sub_1000EA2B();
// void __cdecl operator delete(void *); weak
// void *__cdecl operator new(unsigned int); weak
// _DWORD __cdecl FlushTransmitBuffer(_DWORD, _DWORD); weak
// _DWORD __cdecl GetSerialNumberString(char *, __int16); weak
// bool __cdecl GetFreeBoards(_DWORD, char *, int *); weak
// bool __cdecl GetAllBoards(_DWORD, char *, int *); weak
// _DWORD __cdecl OpenDeviceBySerial(char *); weak
// bool __cdecl IsDeviceConnected(); weak
// int __cdecl CloseDevice(); weak
// _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *); weak
// _DWORD __cdecl OpenDevice(const char *); weak
// _DWORD __cdecl FlushReceiveBuffer(_DWORD, _DWORD); weak
// _DWORD __cdecl SetTimeout(_DWORD, _DWORD); weak
// _DWORD __cdecl GetPacket(_DWORD, _DWORD, char *); weak

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *IsProcessorFeaturePresent)(DWORD ProcessorFeature);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern void (__stdcall *GetLocalTime)(LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern DWORD (__stdcall *GetTickCount)();
// extern int (__cdecl *feof)(FILE *Stream);
// extern size_t (__cdecl *fread)(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern size_t (__cdecl *fwrite)(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern int (__cdecl *fseek)(FILE *Stream, int Offset, int Origin);
// extern uintptr_t (__cdecl *beginthread)(_beginthread_proc_type StartAddress, unsigned int StackSize, void *ArgList);
// extern char *(__cdecl *fgets)(char *Buffer, int MaxCount, FILE *Stream);
// extern int (__cdecl *stricmp)(const char *String1, const char *String2);
// extern int (*sscanf)(const char *const Buffer, const char *const Format, ...);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern errno_t (__cdecl *strcpy_s)(char *Destination, rsize_t SizeInBytes, const char *Source);
// extern int (*fprintf)(FILE *const Stream, const char *const Format, ...);
// extern FILE *(__cdecl *fopen)(const char *FileName, const char *Mode);
// extern int (*sprintf)(char *const Buffer, const char *const Format, ...);
// extern int (*printf)(const char *const Format, ...);
// extern int (__cdecl *strncmp)(const char *Str1, const char *Str2, size_t MaxCount);
_UNKNOWN unk_1000FA70; // weak
void *off_10011010 = &unk_1002B518; // weak
int *off_10011014 = &dword_10013518; // weak
int dword_10011018 = 6200; // weak
int dword_1001101C = 6200; // weak
int dword_10011020 = 200; // weak
int dword_10011024 = 200; // weak
int dword_10011028 = 20; // weak
int dword_1001102C = 20; // weak
char byte_10011030 = '\x01'; // weak
int dword_10011034 = 45056; // weak
int dword_10011038 = 512; // weak
int dword_1001103C = 32; // weak
int dword_10011040 = 15; // weak
int dword_10011044 = 20; // weak
int dword_10011048 = 16384; // weak
int dword_1001104C = 1024; // weak
int dword_10011050 = 32; // weak
int dword_10011054 = 100; // weak
int dword_10011058 = 20; // weak
int dword_1001105C = 32768; // weak
int dword_10011060 = 2048; // weak
int dword_10011064 = 32; // weak
int dword_10011068 = 2000; // weak
int dword_1001106C = 20; // weak
int dword_10011070 = 32768; // weak
int dword_10011074 = 2048; // weak
int dword_10011078 = 64; // weak
int dword_1001107C = 2000; // weak
int dword_10011080 = 20; // weak
int dword_10011084 = 32768; // weak
int dword_10011088 = 2048; // weak
int dword_1001108C = 0; // weak
int dword_10011090 = 2000; // weak
int dword_10011094 = 20; // weak
int dword_10011098 = 32768; // weak
int dword_1001109C = 1024; // weak
int dword_100110A0 = 32; // weak
int dword_100110A4 = 2000; // weak
int dword_100110A8 = 20; // weak
int dword_100110AC = 16384; // weak
int dword_100110B0 = 1024; // weak
int dword_100110B4 = 0; // weak
int dword_100110B8 = 2000; // weak
int dword_100110BC = 20; // weak
int dword_100110C0 = 6200; // weak
int dword_100110C4 = 6200; // weak
int dword_100110C8 = 200; // weak
int dword_100110CC = 1; // weak
char byte_100110D0[256] =
{
  '\0',
  '\a',
  '\x0E',
  '\t',
  '\x1C',
  '\x1B',
  '\x12',
  '\x15',
  '8',
  '?',
  '6',
  '1',
  '$',
  '#',
  '*',
  '-',
  'p',
  'w',
  '~',
  'y',
  'l',
  'k',
  'b',
  'e',
  'H',
  'O',
  'F',
  'A',
  'T',
  'S',
  'Z',
  ']',
  '\xE0',
  '\xE7',
  '\xEE',
  '\xE9',
  '\xFC',
  '\xFB',
  '\xF2',
  '\xF5',
  '\xD8',
  '\xDF',
  '\xD6',
  '\xD1',
  '\xC4',
  '\xC3',
  '\xCA',
  '\xCD',
  '\x90',
  '\x97',
  '\x9E',
  '\x99',
  '\x8C',
  '\x8B',
  '\x82',
  '\x85',
  '\xA8',
  '\xAF',
  '\xA6',
  '\xA1',
  '\xB4',
  '\xB3',
  '\xBA',
  '\xBD',
  '\xC7',
  '\xC0',
  '\xC9',
  '\xCE',
  '\xDB',
  '\xDC',
  '\xD5',
  '\xD2',
  '\xFF',
  '\xF8',
  '\xF1',
  '\xF6',
  '\xE3',
  '\xE4',
  '\xED',
  '\xEA',
  '\xB7',
  '\xB0',
  '\xB9',
  '\xBE',
  '\xAB',
  '\xAC',
  '\xA5',
  '\xA2',
  '\x8F',
  '\x88',
  '\x81',
  '\x86',
  '\x93',
  '\x94',
  '\x9D',
  '\x9A',
  '\'',
  ' ',
  ')',
  '.',
  ';',
  '<',
  '5',
  '2',
  '\x1F',
  '\x18',
  '\x11',
  '\x16',
  '\x03',
  '\x04',
  '\r',
  '\n',
  'W',
  'P',
  'Y',
  '^',
  'K',
  'L',
  'E',
  'B',
  'o',
  'h',
  'a',
  'f',
  's',
  't',
  '}',
  'z',
  '\x89',
  '\x8E',
  '\x87',
  '\x80',
  '\x95',
  '\x92',
  '\x9B',
  '\x9C',
  '\xB1',
  '\xB6',
  '\xBF',
  '\xB8',
  '\xAD',
  '\xAA',
  '\xA3',
  '\xA4',
  '\xF9',
  '\xFE',
  '\xF7',
  '\xF0',
  '\xE5',
  '\xE2',
  '\xEB',
  '\xEC',
  '\xC1',
  '\xC6',
  '\xCF',
  '\xC8',
  '\xDD',
  '\xDA',
  '\xD3',
  '\xD4',
  'i',
  'n',
  'g',
  '`',
  'u',
  'r',
  '{',
  '|',
  'Q',
  'V',
  '_',
  'X',
  'M',
  'J',
  'C',
  'D',
  '\x19',
  '\x1E',
  '\x17',
  '\x10',
  '\x05',
  '\x02',
  '\v',
  '\f',
  '!',
  '&',
  '/',
  '(',
  '=',
  ':',
  '3',
  '4',
  'N',
  'I',
  '@',
  'G',
  'R',
  'U',
  '\\',
  '[',
  'v',
  'q',
  'x',
  '\x7F',
  'j',
  'm',
  'd',
  'c',
  '>',
  '9',
  '0',
  '7',
  '\"',
  '%',
  ',',
  '+',
  '\x06',
  '\x01',
  '\b',
  '\x0F',
  '\x1A',
  '\x1D',
  '\x14',
  '\x13',
  '\xAE',
  '\xA9',
  '\xA0',
  '\xA7',
  '\xB2',
  '\xB5',
  '\xBC',
  '\xBB',
  '\x96',
  '\x91',
  '\x98',
  '\x9F',
  '\x8A',
  '\x8D',
  '\x84',
  '\x83',
  '\xDE',
  '\xD9',
  '\xD0',
  '\xD7',
  '\xC2',
  '\xC5',
  '\xCC',
  '\xCB',
  '\xE6',
  '\xE1',
  '\xE8',
  '\xEF',
  '\xFA',
  '\xFD',
  '\xF4',
  '\xF3'
}; // weak
_UNKNOWN unk_100114FC; // weak
HMODULE hModule; // idb
int dword_10011508; // weak
char byte_1001150C; // weak
char byte_1001150D; // weak
int dword_10011510[1024]; // weak
__int16 word_10012510; // weak
int dword_10012514[]; // weak
int dword_10012518[1024]; // weak
int dword_10013518[24576]; // weak
_UNKNOWN unk_1002B518; // weak
int (__cdecl *dword_1002BD18)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_1002BD1C)(_DWORD); // weak
int (__cdecl *dword_1002BD20)(_DWORD); // weak
int (__cdecl *dword_1002BD24)(_DWORD, _DWORD); // weak
int (__cdecl *dword_1002BD28)(_DWORD, _DWORD); // weak
int (__cdecl *dword_1002BD2C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_1002BD30)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_1002BD34; // weak
char FileName; // idb
char byte_1002BF38; // weak
char byte_1002BF39; // weak
char byte_1002BF3A; // weak
char byte_1002BF3B; // weak
int dword_1002BF3C; // weak
int dword_1002BF40; // weak
int dword_1002BF44; // weak
int dword_1002BF48; // weak
int dword_1002BF4C; // weak
int dword_1002BF50; // weak
int dword_1002BF54; // weak
char byte_1002BF58; // weak
char byte_1002BF59; // weak
char byte_1002BF5A; // weak
__int16 word_1002BF5C; // weak
int dword_1002BF60; // weak
int dword_1002BF64; // weak
int dword_1002BF68; // weak
__int16 word_1002BF70; // weak
char byte_1002BF72[8190]; // weak
__int16 word_1002DF70; // weak
char byte_1002DF72[8190]; // weak
int dword_1002FF70; // weak


//----- (10001000) --------------------------------------------------------
void sub_10001000()
{
  ;
}

//----- (10001010) --------------------------------------------------------
FARPROC __cdecl sub_10001010(LPCSTR lpProcName, _DWORD *a2)
{
  FARPROC result; // eax
  unsigned __int16 v3; // [esp+0h] [ebp-10h]
  unsigned __int16 v4; // [esp+4h] [ebp-Ch]
  int (*aa_c_version)(void); // [esp+8h] [ebp-8h]

  if ( hModule )
    goto LABEL_9;
  sub_10001000();
  hModule = LoadLibraryA("aardvark.dll");
  if ( !hModule )
  {
    *a2 = -1;
    return 0;
  }
  aa_c_version = GetProcAddress(hModule, "aa_c_version");
  if ( !aa_c_version )
  {
    hModule = 0;
    *a2 = -4;
    return 0;
  }
  v3 = aa_c_version();
  v4 = (unsigned int)aa_c_version() >> 16;
  if ( v3 >= 0x50Au && v4 <= 0x50Au )
  {
LABEL_9:
    result = GetProcAddress(hModule, lpProcName);
    *a2 = result != 0 ? 0 : -3;
  }
  else
  {
    hModule = 0;
    *a2 = -4;
    return 0;
  }
  return result;
}

//----- (10001100) --------------------------------------------------------
int __cdecl sub_10001100(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  int v6; // [esp+0h] [ebp-4h] BYREF

  v6 = v4;
  if ( dword_1002BD18 )
    return dword_1002BD18(a1, a2, a3, a4);
  v6 = 0;
  dword_1002BD18 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))sub_10001010("c_aa_find_devices_ext", &v6);
  if ( dword_1002BD18 )
    return dword_1002BD18(a1, a2, a3, a4);
  else
    return v6;
}
// 10001103: variable 'v4' is possibly undefined
// 1002BD18: using guessed type int (__cdecl *dword_1002BD18)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001160) --------------------------------------------------------
int __cdecl sub_10001160(int a1)
{
  int v1; // ecx
  int v3; // [esp+0h] [ebp-4h] BYREF

  v3 = v1;
  if ( dword_1002BD1C )
    return dword_1002BD1C(a1);
  v3 = 0;
  dword_1002BD1C = (int (__cdecl *)(_DWORD))sub_10001010("c_aa_open", &v3);
  if ( dword_1002BD1C )
    return dword_1002BD1C(a1);
  else
    return v3;
}
// 10001163: variable 'v1' is possibly undefined
// 1002BD1C: using guessed type int (__cdecl *dword_1002BD1C)(_DWORD);

//----- (100011B0) --------------------------------------------------------
int __cdecl sub_100011B0(int a1)
{
  int v1; // ecx
  int v3; // [esp+0h] [ebp-4h] BYREF

  v3 = v1;
  if ( dword_1002BD20 )
    return dword_1002BD20(a1);
  v3 = 0;
  dword_1002BD20 = (int (__cdecl *)(_DWORD))sub_10001010("c_aa_close", &v3);
  if ( dword_1002BD20 )
    return dword_1002BD20(a1);
  else
    return v3;
}
// 100011B3: variable 'v1' is possibly undefined
// 1002BD20: using guessed type int (__cdecl *dword_1002BD20)(_DWORD);

//----- (10001200) --------------------------------------------------------
int __cdecl sub_10001200(int a1, int a2)
{
  int v2; // ecx
  int v4; // [esp+0h] [ebp-4h] BYREF

  v4 = v2;
  if ( dword_1002BD24 )
    return dword_1002BD24(a1, a2);
  v4 = 0;
  dword_1002BD24 = (int (__cdecl *)(_DWORD, _DWORD))sub_10001010("c_aa_configure", &v4);
  if ( dword_1002BD24 )
    return dword_1002BD24(a1, a2);
  else
    return v4;
}
// 10001203: variable 'v2' is possibly undefined
// 1002BD24: using guessed type int (__cdecl *dword_1002BD24)(_DWORD, _DWORD);

//----- (10001250) --------------------------------------------------------
int __cdecl sub_10001250(int a1, int a2)
{
  int v2; // ecx
  int v4; // [esp+0h] [ebp-4h] BYREF

  v4 = v2;
  if ( dword_1002BD28 )
    return dword_1002BD28(a1, a2);
  v4 = 0;
  dword_1002BD28 = (int (__cdecl *)(_DWORD, _DWORD))sub_10001010("c_aa_spi_bitrate", &v4);
  if ( dword_1002BD28 )
    return dword_1002BD28(a1, a2);
  else
    return v4;
}
// 10001253: variable 'v2' is possibly undefined
// 1002BD28: using guessed type int (__cdecl *dword_1002BD28)(_DWORD, _DWORD);

//----- (100012A0) --------------------------------------------------------
int __cdecl sub_100012A0(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  int v6; // [esp+0h] [ebp-4h] BYREF

  v6 = v4;
  if ( dword_1002BD2C )
    return dword_1002BD2C(a1, a2, a3, a4);
  v6 = 0;
  dword_1002BD2C = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))sub_10001010("c_aa_spi_configure", &v6);
  if ( dword_1002BD2C )
    return dword_1002BD2C(a1, a2, a3, a4);
  else
    return v6;
}
// 100012A3: variable 'v4' is possibly undefined
// 1002BD2C: using guessed type int (__cdecl *dword_1002BD2C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001300) --------------------------------------------------------
int __cdecl sub_10001300(int a1, unsigned __int16 a2, int a3, unsigned __int16 a4, int a5)
{
  int v5; // ecx
  int v7; // [esp+0h] [ebp-4h] BYREF

  v7 = v5;
  if ( dword_1002BD30 )
    return dword_1002BD30(a1, a2, a3, a4, a5);
  v7 = 0;
  dword_1002BD30 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_10001010("c_aa_spi_write", &v7);
  if ( dword_1002BD30 )
    return dword_1002BD30(a1, a2, a3, a4, a5);
  else
    return v7;
}
// 10001303: variable 'v5' is possibly undefined
// 1002BD30: using guessed type int (__cdecl *dword_1002BD30)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001360) --------------------------------------------------------
int __cdecl sub_10001360(char a1, char a2)
{
  int v3; // [esp+0h] [ebp-14h]
  char v4[4]; // [esp+4h] [ebp-10h] BYREF
  char v5; // [esp+8h] [ebp-Ch] BYREF
  char v6; // [esp+9h] [ebp-Bh]
  int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+10h] [ebp-4h]

  v7 = 0;
  v8 = 0;
  v3 = 0;
  v4[0] = -1;
  v4[1] = 0;
  v5 = a1 | 0x80;
  v6 = a2;
  do
  {
    v7 = sub_10001300(dword_10011508, 2u, (int)&v5, 2u, (int)v4);
    if ( v7 != 2 || (unsigned __int8)v4[0] == 255 )
    {
      v5 = a1 | 0x80;
      v6 = a2;
      ++v8;
    }
    Sleep(1u);
  }
  while ( v8 != 4 && ((unsigned __int8)v4[0] == 255 || v7 != 2) && v8 < 4 );
  if ( v8 == 4 )
    return 805;
  return v3;
}
// 10011508: using guessed type int dword_10011508;

//----- (10001430) --------------------------------------------------------
int __cdecl sub_10001430(__int16 a1, char *a2, __int16 a3)
{
  int v4; // [esp+0h] [ebp-8h]
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < a3; ++i )
  {
    v4 = sub_10001360(i + a1, *a2++);
    if ( v4 )
      return v4;
  }
  return 0;
}

//----- (10001490) --------------------------------------------------------
int __cdecl sub_10001490(unsigned __int16 a1, int a2, __int16 a3)
{
  int v4; // [esp+0h] [ebp-11Ch]
  char v5[260]; // [esp+4h] [ebp-118h] BYREF
  int v6; // [esp+10Ch] [ebp-10h]
  char v7; // [esp+110h] [ebp-Ch] BYREF
  char v8; // [esp+111h] [ebp-Bh]
  int v9; // [esp+114h] [ebp-8h]
  int v10; // [esp+118h] [ebp-4h]

  v6 = 0;
  v4 = 0;
  while ( v6 < a3 + 1 )
  {
    v10 = 0;
    memset(v5, 255, 0x100u);
    v7 = (v6 + a1) & 0x7F;
    v8 = 0;
    v9 = 0;
    do
    {
      Sleep(1u);
      v9 = sub_10001300(dword_10011508, 2u, (int)&v7, 2u, (int)v5);
      if ( !v9 || (unsigned __int8)v5[0] == 255 )
      {
        if ( !v10 && v6 )
        {
          v7 = (--v6 + a1) & 0x7F;
          v8 = 0;
        }
        ++v10;
      }
    }
    while ( v10 != 4 && (v9 != 2 || (unsigned __int8)v5[0] == 255) );
    if ( (unsigned __int8)v5[0] == a1 + v6 - 1 )
      *(_BYTE *)(v6 + a2 - 1) = v5[1];
    ++v6;
    if ( v10 == 4 )
      return 805;
  }
  return v4;
}
// 10011508: using guessed type int dword_10011508;

//----- (100015F0) --------------------------------------------------------
int sub_100015F0()
{
  int v1; // [esp+8h] [ebp-4h]

  sub_10001200(dword_10011508, 3);
  sub_100012A0(dword_10011508, 0, 0, 0);
  v1 = sub_10001250(dword_10011508, 1000);
  return printf("Bitrate set to %d kHz\n", v1);
}
// 10011508: using guessed type int dword_10011508;

//----- (10001660) --------------------------------------------------------
int __cdecl AA_Control(int a1, int a2)
{
  __int16 v3[16]; // [esp+8h] [ebp-78h] BYREF
  int v4[18]; // [esp+28h] [ebp-58h] BYREF
  int v5; // [esp+70h] [ebp-10h]
  int v6; // [esp+74h] [ebp-Ch]
  int i; // [esp+78h] [ebp-8h]
  int v8; // [esp+7Ch] [ebp-4h]

  v4[17] = 16;
  v8 = 0;
  v5 = 9999;
  switch ( a1 )
  {
    case 0:
      dword_10011508 = -1;
      v6 = sub_10001100(16, (int)v3, 16, (int)v4);
      printf("%d device(s) found:\n", v6);
      for ( i = 0; i < 16; ++i )
      {
        if ( (v3[i] & 0x8000) != 0 )
          v3[i] &= ~0x8000u;
      }
      i = 0;
      break;
    case 1:
      v5 = sub_100011B0(dword_10011508);
      dword_10011508 = -1;
      return v5;
    case 2:
      return dword_10011508;
    case 3:
      return sub_10001250(dword_10011508, 1000);
    case 4:
      return sub_10001250(dword_10011508, 2000);
    case 5:
      return sub_10001250(dword_10011508, 400);
    case 6:
      return sub_100012A0(dword_10011508, 0, 0, 0);
    case 7:
      return sub_100012A0(dword_10011508, 0, 1, 0);
    case 8:
      return sub_100012A0(dword_10011508, 1, 0, 0);
    case 9:
      return sub_100012A0(dword_10011508, 1, 1, 0);
    default:
      return v5;
  }
  while ( 1 )
  {
    if ( i >= 16 )
      return v5;
    if ( v4[i] % 0xF4240u == a2 )
      break;
LABEL_15:
    ++i;
  }
  if ( (v3[i] & 0x8000) != 0 )
    return 1;
  dword_10011508 = sub_10001160((unsigned __int16)v3[i]);
  v5 = dword_10011508;
  if ( dword_10011508 > 0 )
  {
    sub_100015F0();
    sub_10001250(dword_10011508, 1000);
    printf("\nAardvark Serial Number xxxx-%06d Opened\n", v4[i] % 0xF4240u);
    printf("Setup for bq769x2 SPI using 1MHz bitrate.\n\n");
    goto LABEL_15;
  }
  printf("Unable to open Aardvark device on port %d\n", dword_100110CC);
  printf("Error code = %d\n", dword_10011508);
  return dword_10011508;
}
// 100110CC: using guessed type int dword_100110CC;
// 10011508: using guessed type int dword_10011508;
// 10001660: using guessed type __int16 var_78[16];

//----- (10001940) --------------------------------------------------------
int sub_10001940()
{
  int Packet; // [esp+0h] [ebp-114h]
  char v2[2]; // [esp+4h] [ebp-110h] BYREF
  char v3[266]; // [esp+6h] [ebp-10Eh] BYREF

  v2[0] = 0;
  v2[1] = 0;
  memset(v3, 0, 0x105u);
  Packet = GetPacket(0, 2, v2);
  if ( Packet && Packet != -1 )
  {
    GetPacket(0, 12, v3);
    FlushReceiveBuffer(0, 0);
  }
  return 0;
}
// 1000F10C: using guessed type _DWORD __cdecl FlushReceiveBuffer(_DWORD, _DWORD);
// 1000F114: using guessed type _DWORD __cdecl GetPacket(_DWORD, _DWORD, char *);

//----- (100019E0) --------------------------------------------------------
int __cdecl OpenDeviceA(const char *a1)
{
  return OpenDevice(a1);
}
// 1000F108: using guessed type _DWORD __cdecl OpenDevice(const char *);

//----- (10001A00) --------------------------------------------------------
int CloseDeviceA()
{
  return CloseDevice();
}
// 1000F100: using guessed type int __cdecl CloseDevice();

//----- (10001A10) --------------------------------------------------------
int __cdecl WritePacket(int a1, char *a2, _DWORD *a3)
{
  *a3 = 0;
  *a3 = PutPacket(0, a1, a2);
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10001A40) --------------------------------------------------------
int __cdecl ReadPacket(int a1, char *a2, _DWORD *a3)
{
  *a3 = GetPacket(0, a1, a2);
  return 0;
}
// 1000F114: using guessed type _DWORD __cdecl GetPacket(_DWORD, _DWORD, char *);

//----- (10001A60) --------------------------------------------------------
BOOL __cdecl sub_10001A60(char *a1)
{
  int Packet; // [esp+0h] [ebp-4h]

  Packet = GetPacket(0, 1, a1);
  return Packet && Packet != -1;
}
// 1000F114: using guessed type _DWORD __cdecl GetPacket(_DWORD, _DWORD, char *);

//----- (10001AA0) --------------------------------------------------------
int __cdecl sub_10001AA0(char *a1, int a2)
{
  int v2; // esi
  DWORD v4; // [esp+4h] [ebp-10h]
  BOOL v5; // [esp+8h] [ebp-Ch]
  DWORD TickCount; // [esp+10h] [ebp-4h]

  do
  {
    GetTickCount();
    SetTimeout(0, a2);
    TickCount = GetTickCount();
    v5 = sub_10001A60(a1);
    SetTimeout(0, 1000);
    if ( !v5 )
      goto LABEL_6;
  }
  while ( (unsigned __int8)*a1 != 170 );
  if ( GetPacket(0, 5, a1 + 1) != 5 || (v2 = (unsigned __int8)a1[5] + 2, v2 != GetPacket(0, v2, a1 + 6)) )
  {
LABEL_6:
    SetTimeout(0, 1);
    return 0;
  }
  SetTimeout(0, 1);
  if ( !sub_10001F70((unsigned __int8 *)a1) )
    return (unsigned __int8)a1[5] + 8;
  v4 = GetTickCount() - TickCount;
  if ( a2 == v4 )
    return sub_10001AA0(a1, 1);
  else
    return sub_10001AA0(a1, a2 - v4);
}
// 1000F110: using guessed type _DWORD __cdecl SetTimeout(_DWORD, _DWORD);
// 1000F114: using guessed type _DWORD __cdecl GetPacket(_DWORD, _DWORD, char *);

//----- (10001C10) --------------------------------------------------------
int sub_10001C10()
{
  char v1; // [esp+0h] [ebp-220h] BYREF
  unsigned __int8 v2; // [esp+1h] [ebp-21Fh]
  int v3; // [esp+10Ch] [ebp-114h]
  char v4[264]; // [esp+110h] [ebp-110h] BYREF
  int v5; // [esp+21Ch] [ebp-4h]

  v3 = 0;
  v5 = 0;
  if ( !sub_10001E70(v4, 128, 0, 0) )
    return 9;
  if ( PutPacket(0, 8, v4) != 8 )
    return 2;
  SetTimeout(0, 1500);
  if ( !sub_10001AA0(&v1, 2000) )
    return 8;
  if ( sub_10001FF0((int)&v1) )
  {
    v3 = sub_10002BD0((int)&v1);
    while ( sub_10001AA0(&v1, 2000) )
    {
      if ( v2 == 192 )
        return v3;
    }
    return v3;
  }
  else if ( v2 == 192 )
  {
    return 0;
  }
  else
  {
    return 10;
  }
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 1000F110: using guessed type _DWORD __cdecl SetTimeout(_DWORD, _DWORD);

//----- (10001D40) --------------------------------------------------------
int __cdecl sub_10001D40(__int16 a1, _WORD *a2, __int16 a3)
{
  char v4; // [esp+0h] [ebp-11Ch] BYREF
  char v5[3]; // [esp+1h] [ebp-11Bh] BYREF
  char v6[264]; // [esp+4h] [ebp-118h] BYREF
  char v7[12]; // [esp+10Ch] [ebp-10h] BYREF

  *a2 = 0;
  v4 = a3;
  v5[0] = a1;
  sub_10001E70(v7, 136, 1u, (int)v5);
  PutPacket(0, 9, v7);
  if ( !sub_10001E70(v7, 1, 2u, (int)&v4) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 10, v7) != 10 )
    return 2;
  if ( !sub_10001AA0(v6, 2000) )
    return 8;
  if ( sub_10001FF0((int)v6) )
    return sub_10002BD0((int)v6);
  if ( v6[1] != 65 )
    return 10;
  *a2 = ((unsigned __int8)v6[8] << 8) + (unsigned __int8)v6[7];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10001D40: using guessed type char var_11B[3];

//----- (10001E70) --------------------------------------------------------
int __cdecl sub_10001E70(_BYTE *a1, char a2, unsigned __int8 N, int a4)
{
  int i; // [esp+0h] [ebp-4h]

  *a1 = -86;
  a1[1] = a2;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = N;
  for ( i = 0; i < N; ++i )
    a1[i + 6] = *(_BYTE *)(i + a4);
  a1[N + 7] = 85;
  sub_10001F00((int)a1);
  return 1;
}

//----- (10001F00) --------------------------------------------------------
unsigned __int8 __cdecl sub_10001F00(int a1)
{
  unsigned __int8 result; // al
  unsigned __int8 v3; // [esp+3h] [ebp-5h]
  int v4; // [esp+4h] [ebp-4h]
  int v5; // [esp+4h] [ebp-4h]
  unsigned __int8 *v6; // [esp+10h] [ebp+8h]

  v3 = 0;
  v4 = *(unsigned __int8 *)(a1 + 5);
  v6 = (unsigned __int8 *)(a1 + 1);
  v5 = v4 + 5;
  while ( v5-- )
    v3 = byte_100110D0[v3 ^ *v6++];
  result = v3;
  *v6 = v3;
  return result;
}

//----- (10001F70) --------------------------------------------------------
char __cdecl sub_10001F70(unsigned __int8 *a1)
{
  unsigned __int8 v2; // [esp+1h] [ebp-1h]

  if ( *a1 != 170 )
    return -2;
  v2 = a1[a1[5] + 6];
  sub_10001F00((int)a1);
  if ( v2 != a1[a1[5] + 6] )
    return -4;
  if ( a1[a1[5] + 7] == 85 )
    return 0;
  return -2;
}

//----- (10001FF0) --------------------------------------------------------
bool __cdecl sub_10001FF0(int a1)
{
  return *(_BYTE *)(a1 + 1) == 70;
}

//----- (10002010) --------------------------------------------------------
int __cdecl ReadSMBusWord(__int16 a1, _WORD *a2, __int16 a3)
{
  char v4; // [esp+0h] [ebp-11Ch] BYREF
  unsigned __int8 v5[3]; // [esp+1h] [ebp-11Bh] BYREF
  char v6[264]; // [esp+4h] [ebp-118h] BYREF
  char v7[12]; // [esp+10Ch] [ebp-10h] BYREF

  *a2 = 0;
  v4 = a3;
  v5[0] = a1;
  if ( !sub_10001E70(v7, 1, 2u, (int)&v4) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 10, v7) != 10 )
    return 2;
  sub_10005B90((int)&FileName, "ReadSMBusWord", a3, 1, v5);
  if ( !sub_10001AA0(v6, 2000) )
    return 8;
  if ( sub_10001FF0((int)v6) )
    return sub_10002BD0((int)v6);
  if ( v6[1] != 65 )
    return 10;
  *a2 = ((unsigned __int8)v6[8] << 8) + (unsigned __int8)v6[7];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10002010: using guessed type unsigned __int8 var_11B[3];

//----- (10002140) --------------------------------------------------------
int __cdecl WriteSMBusWord(__int16 a1, __int16 a2, __int16 a3)
{
  char v4; // [esp+0h] [ebp-18h] BYREF
  unsigned __int8 v5[3]; // [esp+1h] [ebp-17h] BYREF
  char v6[12]; // [esp+4h] [ebp-14h] BYREF
  int v7; // [esp+14h] [ebp-4h]

  v4 = a3;
  v5[0] = a1;
  v5[1] = a2;
  v5[2] = (unsigned __int16)(a2 & 0xFF00) >> 8;
  v7 = 0;
  if ( !sub_10001E70(v6, 4, 4u, (int)&v4) )
    return 9;
  if ( PutPacket(0, 12, v6) != 12 )
    return 2;
  sub_10005B90((int)&FileName, "WriteSMBusWord", a3, 3, v5);
  return sub_10001C10();
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10002200) --------------------------------------------------------
int __cdecl WriteSMBusBlock(unsigned __int8 a1, int a2, __int16 a3, __int16 a4)
{
  int v5; // [esp+0h] [ebp-254h] BYREF
  int v6; // [esp+10h] [ebp-244h]
  int i; // [esp+18h] [ebp-23Ch]
  int v8; // [esp+1Ch] [ebp-238h]
  int v9; // [esp+20h] [ebp-234h]
  char v10; // [esp+24h] [ebp-230h] BYREF
  unsigned __int8 v11; // [esp+25h] [ebp-22Fh] BYREF
  unsigned __int8 v12; // [esp+26h] [ebp-22Eh]
  char v13[265]; // [esp+27h] [ebp-22Dh]
  int v14; // [esp+130h] [ebp-124h]
  char v15[268]; // [esp+134h] [ebp-120h] BYREF
  int *v16; // [esp+244h] [ebp-10h]
  int v17; // [esp+250h] [ebp-4h]

  v16 = &v5;
  v14 = 0;
  if ( a3 > 263 )
    return 102;
  v17 = 0;
  v10 = a4;
  v11 = a1;
  v12 = a3;
  for ( i = 0; i < a3; ++i )
    v13[i] = *(_BYTE *)(i + a2);
  v8 = 0;
  if ( !sub_10001E70(v15, 5, v12 + 3, (int)&v10) )
    return 9;
  v9 = v12 + 11;
  v6 = PutPacket(0, v9, v15);
  if ( v6 != v9 )
    return 2;
  v17 = -1;
  sub_10005B90((int)&FileName, "WriteSMBusBlock", a4, a3 + 2, &v11);
  return sub_10001C10();
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10002200: using guessed type char var_22D[265];

//----- (100023C0) --------------------------------------------------------
int __cdecl ReadSMBusBlock(__int16 a1, int a2, __int16 *a3, __int16 a4)
{
  int i; // [esp+0h] [ebp-32Ch]
  char v6; // [esp+4h] [ebp-328h] BYREF
  unsigned __int8 v7[263]; // [esp+5h] [ebp-327h] BYREF
  char v8[268]; // [esp+10Ch] [ebp-220h] BYREF
  int v9; // [esp+218h] [ebp-114h]
  char v10[264]; // [esp+21Ch] [ebp-110h] BYREF
  int v11; // [esp+328h] [ebp-4h]

  v9 = 0;
  v6 = a4;
  v7[0] = a1;
  v11 = 0;
  if ( !sub_10001E70(v10, 2, 2u, (int)&v6) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 10, v10) != 10 )
    return 2;
  sub_10005B90((int)&FileName, "ReadSMBusBlock", a4, 1, v7);
  if ( !sub_10001AA0(v8, 2000) )
    return 8;
  if ( sub_10001FF0((int)v8) )
    return sub_10002BD0((int)v8);
  if ( v8[1] != 66 )
    return 10;
  *a3 = (unsigned __int8)v8[7];
  for ( i = 0; i < *a3; ++i )
    *(_BYTE *)(i + a2) = v8[i + 8];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 100023C0: using guessed type unsigned __int8 var_327[263];

//----- (10002570) --------------------------------------------------------
int __cdecl sub_10002570(int a1, _DWORD *a2, _BYTE *a3, size_t Size)
{
  unsigned int v5; // [esp+20h] [ebp-28h]
  int v6; // [esp+34h] [ebp-14h]
  unsigned int i; // [esp+38h] [ebp-10h]
  const char *v8; // [esp+3Ch] [ebp-Ch]
  char *v9; // [esp+3Ch] [ebp-Ch]
  int v10; // [esp+40h] [ebp-8h] BYREF
  _BYTE *v11; // [esp+44h] [ebp-4h]

  *a2 = a1;
  v10 = 0x2000;
  v11 = a3;
  if ( GetFreeBoards(a1, (char *)&word_1002DF70, &v10) )
  {
    *a2 = word_1002DF70;
    if ( (int)(Size - 1) < v10 )
    {
      if ( v10 >= 5 )
      {
        v8 = (const char *)(&word_1002DF70 + 1);
        if ( *a2 )
        {
          v6 = 0;
          do
          {
            if ( v8 >= (const char *)&dword_1002FF70 )
              break;
            v5 = strlen(v8);
            if ( !v5 )
              break;
            ++v6;
            v9 = (char *)&v8[v5];
            *v9 = 44;
            v8 = v9 + 1;
          }
          while ( v6 < *a2 );
          *a2 = v6;
          for ( i = 0; i < strlen(byte_1002DF72); ++i )
            v11[i] = byte_1002DF72[i];
          v11[i - 1] = 0;
          return 0;
        }
        else
        {
          *a3 = 0;
          return 0;
        }
      }
      else
      {
        memset(a3, 0, Size);
        return 0;
      }
    }
    else
    {
      memset(a3, 0, Size);
      return 101;
    }
  }
  else
  {
    memset(a3, 0, Size);
    *a2 = 0;
    return 0;
  }
}
// 1000F0F0: using guessed type bool __cdecl GetFreeBoards(_DWORD, char *, int *);
// 1002DF70: using guessed type __int16 word_1002DF70;
// 1002FF70: using guessed type int dword_1002FF70;

//----- (10002770) --------------------------------------------------------
int __cdecl GetAllBoards(int a1, _DWORD *a2, _BYTE *a3, size_t Size)
{
  unsigned int v5; // [esp+30h] [ebp-18h]
  int v6; // [esp+34h] [ebp-14h]
  unsigned int i; // [esp+38h] [ebp-10h]
  const char *v8; // [esp+3Ch] [ebp-Ch]
  char *v9; // [esp+3Ch] [ebp-Ch]
  int v10; // [esp+40h] [ebp-8h] BYREF
  _BYTE *v11; // [esp+44h] [ebp-4h]

  *a2 = a1;
  v10 = 0x2000;
  v11 = a3;
  if ( GetAllBoards(a1, (char *)&word_1002BF70, &v10) )
  {
    *a2 = word_1002BF70;
    v8 = (const char *)(&word_1002BF70 + 1);
    if ( *a2 )
    {
      v6 = 0;
      do
      {
        if ( v8 >= (const char *)&word_1002DF70 )
          break;
        v5 = strlen(v8);
        if ( !v5 )
          break;
        ++v6;
        v9 = (char *)&v8[v5];
        *v9 = 44;
        v8 = v9 + 1;
      }
      while ( v6 < *a2 );
      *a2 = v6;
      for ( i = 0; i < strlen(byte_1002BF72); ++i )
        v11[i] = byte_1002BF72[i];
      v11[i] = 0;
      return 0;
    }
    else
    {
      *a3 = 0;
      return 0;
    }
  }
  else
  {
    memset(a3, 0, Size);
    *a2 = 0;
    return 0;
  }
}
// 1000F0F4: using guessed type bool __cdecl GetAllBoards(_DWORD, char *, int *);
// 1002BF70: using guessed type __int16 word_1002BF70;
// 1002DF70: using guessed type __int16 word_1002DF70;

//----- (10002920) --------------------------------------------------------
int __cdecl I2CPower(__int16 a1)
{
  __int16 v2; // [esp+8h] [ebp-4h] BYREF

  v2 = 0;
  return sub_10002970(0, a1 != 0, 0, &v2);
}

//----- (10002970) --------------------------------------------------------
int __cdecl sub_10002970(__int16 a1, __int16 a2, __int16 a3, _WORD *a4)
{
  int result; // eax
  char v5[8]; // [esp+Ch] [ebp-228h] BYREF
  char v6; // [esp+14h] [ebp-220h]
  char v7; // [esp+11Ah] [ebp-11Ah]
  unsigned __int8 v8; // [esp+11Bh] [ebp-119h]
  char v9[268]; // [esp+11Ch] [ebp-118h] BYREF
  char v10[7]; // [esp+22Ch] [ebp-8h] BYREF
  char v11; // [esp+233h] [ebp-1h]

  v10[0] = a2;
  v10[1] = a3;
  v10[2] = *a4;
  v11 = 0;
  switch ( a1 )
  {
    case 0:
      v7 = 24;
      v8 = 1;
      goto LABEL_7;
    case 1:
      v7 = 26;
      v8 = 3;
      goto LABEL_7;
    case 2:
      v7 = 25;
      v11 = 1;
      v8 = 2;
      goto LABEL_7;
    case 3:
      v7 = 28;
      v8 = 1;
LABEL_7:
      if ( sub_10001E70(v9, v7, v8, (int)v10) )
      {
        if ( PutPacket(0, v8 + 8, v9) == v8 + 8 )
        {
          if ( v11 )
          {
            if ( sub_10001AA0(v5, 2000) )
            {
              if ( sub_10001FF0((int)v5) )
              {
                result = sub_10002BD0((int)v5);
              }
              else if ( v5[1] == 81 )
              {
                if ( v6 )
                {
                  if ( !sub_10001AA0(v5, 2000) || sub_10001FF0((int)v5) )
                  {
                    switch ( v6 )
                    {
                      case 1:
                        result = 772;
                        break;
                      case 2:
                        result = 92;
                        break;
                      case 3:
                        result = 94;
                        break;
                      default:
                        result = 100;
                        break;
                    }
                  }
                  else
                  {
                    result = 12;
                  }
                }
                else
                {
                  *a4 = (unsigned __int8)v5[7];
                  result = 0;
                }
              }
              else
              {
                result = 10;
              }
            }
            else
            {
              result = 8;
            }
          }
          else
          {
            Sleep(0x32u);
            result = (__int16)sub_10002D20();
          }
        }
        else
        {
          result = 2;
        }
      }
      else
      {
        result = 9;
      }
      break;
    default:
      result = 7;
      break;
  }
  return result;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10002BD0) --------------------------------------------------------
int __cdecl sub_10002BD0(int a1)
{
  int result; // eax

  switch ( *(_BYTE *)(a1 + 7) )
  {
    case 0x91:
      result = 3;
      break;
    case 0x92:
      result = 260;
      break;
    case 0x93:
      result = 772;
      break;
    case 0x94:
      result = 260;
      break;
    case 0x95:
      result = 5;
      break;
    default:
      result = 6;
      break;
  }
  return result;
}

//----- (10002C50) --------------------------------------------------------
int __cdecl WriteSMBusCmd(unsigned __int8 a1, __int16 a2)
{
  return sub_10002C70(a1, a2);
}

//----- (10002C70) --------------------------------------------------------
int __cdecl sub_10002C70(unsigned __int8 a1, __int16 a2)
{
  char v3; // [esp+0h] [ebp-14h] BYREF
  unsigned __int8 v4[3]; // [esp+1h] [ebp-13h] BYREF
  char v5[12]; // [esp+4h] [ebp-10h] BYREF

  v3 = a2;
  v4[0] = a1;
  if ( !sub_10001E70(v5, 6, 2u, (int)&v3) )
    return 9;
  if ( PutPacket(0, 10, v5) != 10 )
    return 2;
  sub_10005B90((int)&FileName, "WriteSMBusCmd", a2, 1, v4);
  return sub_10001C10();
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10002C70: using guessed type unsigned __int8 var_13[3];

//----- (10002D10) --------------------------------------------------------
int CheckForError()
{
  return (__int16)sub_10002D20();
}

//----- (10002D20) --------------------------------------------------------
int sub_10002D20()
{
  char v1[268]; // [esp+0h] [ebp-110h] BYREF

  if ( !sub_10001AA0(v1, 0) )
    return 0;
  if ( sub_10001FF0((int)v1) )
    return sub_10002BD0((int)v1);
  return 10;
}

//----- (10002D90) --------------------------------------------------------
int __cdecl sub_10002D90(char a1, char a2)
{
  char v3[4]; // [esp+0h] [ebp-18h] BYREF
  char v4[16]; // [esp+4h] [ebp-14h] BYREF

  v3[0] = a1;
  v3[1] = a2;
  if ( !sub_10001E70(v4, 27, 2u, (int)v3) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 10, v4) == 10 )
    return 0;
  else
    return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10002E00) --------------------------------------------------------
int __cdecl sub_10002E00(int a1, unsigned __int8 a2, __int16 a3)
{
  int v4; // esi
  char v5; // [esp+6h] [ebp-3Ah]
  char v6; // [esp+7h] [ebp-39h]
  char v7[8]; // [esp+8h] [ebp-38h] BYREF
  __int16 v8; // [esp+10h] [ebp-30h] BYREF
  char v9[32]; // [esp+14h] [ebp-2Ch] BYREF
  unsigned __int8 v10; // [esp+3Ah] [ebp-6h]
  unsigned __int8 v11; // [esp+3Bh] [ebp-5h]
  __int16 v12; // [esp+3Ch] [ebp-4h]

  v5 = a2;
  switch ( a1 )
  {
    case 3:
      sub_10002D90(0, 0);
      return 0;
    case 4:
      sub_10002D90(0, 1);
      return 0;
    case 5:
      sub_10002D90(1, 0);
      return 0;
    case 6:
      sub_10002D90(1, 1);
      return 0;
    default:
      v10 = 0;
      if ( a1 && a1 != 8 )
      {
        if ( a2 <= 0x7Fu )
        {
          v5 = a2 | 0x80;
        }
        else
        {
          v12 = sub_10002FF0(0, a1, 0xFFu, &v8);
          v5 = a2 + 0x80;
        }
      }
      if ( a1 == 1 )
      {
        v6 = 19;
      }
      else if ( a1 == 2 )
      {
        v6 = 21;
      }
      else if ( a1 )
      {
        if ( a1 == 7 )
        {
          v6 = 31;
        }
        else if ( a1 == 8 )
        {
          v6 = 33;
        }
      }
      else
      {
        v6 = 23;
      }
      if ( a1 == 2 || a1 == 7 )
        v11 = 3;
      else
        v11 = 2;
      v7[v10++] = v5;
      v7[v10++] = a3;
      if ( a1 == 2 || a1 == 7 )
        v7[v10++] = (unsigned __int16)(a3 & 0xFF00) >> 8;
      if ( sub_10001E70(v9, v6, v11, (int)v7) )
      {
        v4 = (unsigned __int8)v9[5] + 8;
        if ( v4 == PutPacket(0, v4, v9) )
          return sub_10002D20();
        else
          return 2;
      }
      else
      {
        return 9;
      }
  }
}
// 10002F8A: variable 'v6' is possibly undefined
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10002E00: using guessed type char var_38[8];

//----- (10002FF0) --------------------------------------------------------
int __cdecl sub_10002FF0(int a1, int a2, unsigned __int8 a3, _WORD *a4)
{
  int v5; // esi
  char v6; // al
  char v7; // [esp+Fh] [ebp-35h]
  char v8[8]; // [esp+10h] [ebp-34h] BYREF
  unsigned __int8 v9[8]; // [esp+18h] [ebp-2Ch] BYREF
  unsigned __int8 v10; // [esp+20h] [ebp-24h]
  char v11; // [esp+21h] [ebp-23h]
  unsigned __int8 v12; // [esp+3Eh] [ebp-6h]
  unsigned __int8 v13; // [esp+3Fh] [ebp-5h]
  int v14; // [esp+40h] [ebp-4h]

  *a4 = 0;
  v12 = 0;
  if ( a2 == 1 )
  {
    v7 = 18;
  }
  else if ( a2 == 2 )
  {
    v7 = 20;
  }
  else if ( a2 )
  {
    if ( a2 == 8 )
      v7 = 35;
  }
  else
  {
    v7 = 22;
  }
  v13 = 1;
  v8[v12++] = a3;
  if ( !sub_10001E70(v9, v7, v13, (int)v8) )
    return 9;
  sub_10001940();
  v5 = v9[5] + 8;
  if ( v5 != PutPacket(0, v5, (char *)v9) )
    return 2;
  if ( !sub_10001AA0((char *)v9, 2000) )
    return 8;
  v6 = sub_10001F70(v9);
  v14 = v6;
  if ( v6 )
    return v14;
  if ( sub_10001FF0((int)v9) )
    return sub_10002BD0((int)v9);
  if ( a2 == 2 )
  {
    if ( v11 )
      return (__int16)sub_10002D20();
  }
  else if ( v10 )
  {
    return (__int16)sub_10002D20();
  }
  if ( a3 == v9[6] )
  {
    *a4 = v9[7];
    if ( a2 == 2 )
      *a4 += v10 << 8;
  }
  return v14;
}
// 1000306C: variable 'v7' is possibly undefined
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10002FF0: using guessed type char var_34[8];

//----- (100031A0) --------------------------------------------------------
int __cdecl HDQ8ReadByte(__int16 a1, _WORD *a2)
{
  return sub_100031E0(1, a1, a2);
}

//----- (100031C0) --------------------------------------------------------
int __cdecl HDQ8WriteByte(__int16 a1, __int16 a2)
{
  return (__int16)sub_10002E00(1, a1, (unsigned __int8)a2);
}

//----- (100031E0) --------------------------------------------------------
__int16 __cdecl sub_100031E0(int a1, __int16 a2, _WORD *a3)
{
  int v4; // [esp+4h] [ebp-8h]

  if ( !a1 )
    return sub_10002FF0(0, 0, a2 | 0x80, a3);
  if ( a1 == 8 )
    return sub_10002FF0(0, 8, a2, a3);
  if ( a2 <= 127 )
  {
    v4 = sub_10002FF0(0, a1, a2, a3);
    if ( v4 )
      return v4;
  }
  if ( a2 == 127 )
    return sub_10002FF0(0, a1, 0xFFu, a3);
  if ( a2 > 127 )
  {
    v4 = sub_10002FF0(0, a1, a2, a3);
    if ( v4 )
      return v4;
  }
  return v4;
}
// 100032EE: variable 'v4' is possibly undefined

//----- (10003300) --------------------------------------------------------
int __cdecl Delay(int a1)
{
  int result; // eax
  unsigned __int8 v2; // [esp+3h] [ebp-15h] BYREF
  unsigned int v3; // [esp+4h] [ebp-14h]
  char v4[12]; // [esp+8h] [ebp-10h] BYREF

  if ( a1 < 0 )
    a1 = 0x7FFFFFFF;
  if ( a1 > 0x3FFFFFFF )
    a1 = 0x7FFFFFFF;
  result = 10 * a1;
  v3 = 10 * a1;
  while ( v3 )
  {
    if ( v3 <= 0xFF )
      v2 = v3;
    else
      v2 = -1;
    v3 -= v2;
    sub_10001E70(v4, 136, 1u, (int)&v2);
    result = PutPacket(0, 9, v4);
  }
  return result;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (100033B0) --------------------------------------------------------
int __cdecl ReadI2CBusBlockNcmd(int a1, __int16 *a2, __int16 a3)
{
  char v4[264]; // [esp+0h] [ebp-330h] BYREF
  char v5[268]; // [esp+108h] [ebp-228h] BYREF
  int v6; // [esp+214h] [ebp-11Ch]
  char v7[268]; // [esp+218h] [ebp-118h] BYREF
  __int16 i; // [esp+328h] [ebp-8h]
  int v9; // [esp+32Ch] [ebp-4h]

  v6 = 0;
  v4[0] = a3;
  v4[1] = *a2;
  v9 = 0;
  if ( !sub_10001E70(v7, 17, 2u, (int)v4) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 10, v7) != 10 )
    return 2;
  if ( !sub_10001AA0(v5, 2000) )
    return 8;
  if ( sub_10001FF0((int)v5) )
    return sub_10002BD0((int)v5);
  if ( v5[1] != 80 )
    return 10;
  *a2 = (unsigned __int8)v5[6];
  for ( i = 0; i < *a2; ++i )
    *(_BYTE *)(a1 + i) = v5[i + 7];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10003500) --------------------------------------------------------
int __cdecl sub_10003500(_BYTE *a1)
{
  char v2; // [esp+4h] [ebp-Ch]
  int v3; // [esp+8h] [ebp-8h]
  char v4; // [esp+Fh] [ebp-1h]

  v2 = a1[1];
  if ( v2 == 70 || v2 == 77 )
  {
    v4 = a1[7];
  }
  else
  {
    if ( v2 != -61 )
      return 12;
    v4 = a1[6];
  }
  switch ( v4 )
  {
    case -128:
      v3 = 12;
      break;
    case -127:
      v3 = 81;
      break;
    case -126:
      v3 = 82;
      break;
    case -125:
      v3 = 83;
      break;
    case -124:
      v3 = 84;
      break;
    case -123:
      v3 = 85;
      break;
    case -122:
      v3 = 86;
      break;
    case -121:
      v3 = 87;
      break;
    case -120:
      v3 = 88;
      break;
    case -112:
      v3 = 90;
      break;
    case -111:
      v3 = 3;
      break;
    case -110:
      v3 = 92;
      break;
    case -109:
      v3 = 772;
      break;
    case -108:
      v3 = 94;
      break;
    case -107:
      v3 = 95;
      break;
    case -106:
      v3 = 6;
      break;
    case -105:
      v3 = 97;
      break;
    case -104:
      v3 = 98;
      break;
    case -103:
      v3 = 99;
      break;
    default:
      v3 = 100;
      break;
  }
  return v3;
}

//----- (100036A0) --------------------------------------------------------
int __cdecl I2CReadBlock(__int16 a1, int a2, __int16 a3, __int16 a4)
{
  int i; // [esp+0h] [ebp-32Ch]
  char v6[264]; // [esp+4h] [ebp-328h] BYREF
  char v7[268]; // [esp+10Ch] [ebp-220h] BYREF
  int v8; // [esp+218h] [ebp-114h]
  char v9[264]; // [esp+21Ch] [ebp-110h] BYREF
  int v10; // [esp+328h] [ebp-4h]

  v8 = 0;
  v6[0] = a4;
  v6[1] = a1;
  v6[2] = a3;
  v10 = 0;
  if ( !sub_10001E70(v9, 29, 3u, (int)v6) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 11, v9) != 11 )
    return 2;
  if ( !sub_10001AA0(v7, 2000) )
    return 8;
  if ( sub_10001FF0((int)v7) )
    return sub_10002BD0((int)v7);
  if ( v7[1] != 82 )
    return 10;
  for ( i = 0; i < a3; ++i )
    *(_BYTE *)(i + a2) = v7[i + 8];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10003800) --------------------------------------------------------
int __cdecl I2CWriteBlock(__int16 a1, int a2, __int16 a3, __int16 a4)
{
  char v5[264]; // [esp+0h] [ebp-220h] BYREF
  int i; // [esp+108h] [ebp-118h]
  int v7; // [esp+10Ch] [ebp-114h]
  char v8[264]; // [esp+110h] [ebp-110h] BYREF
  int v9; // [esp+21Ch] [ebp-4h]

  v7 = 0;
  v5[0] = a4;
  v5[1] = a1;
  v5[2] = a3;
  v9 = 0;
  for ( i = 0; i < a3; ++i )
    v5[i + 3] = *(_BYTE *)(i + a2);
  if ( !sub_10001E70(v8, 30, a3 + 3, (int)v5) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, a3 + 11, v8) == a3 + 11 )
    return sub_10001C10();
  else
    return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10003910) --------------------------------------------------------
int __cdecl I2CLtReadBlock(__int16 a1, __int16 a2, int a3, __int16 a4)
{
  int i; // [esp+0h] [ebp-32Ch]
  char v6[264]; // [esp+4h] [ebp-328h] BYREF
  char v7[268]; // [esp+10Ch] [ebp-220h] BYREF
  int v8; // [esp+218h] [ebp-114h]
  char v9[264]; // [esp+21Ch] [ebp-110h] BYREF
  int v10; // [esp+328h] [ebp-4h]

  v8 = 0;
  if ( !sub_10005EC0() )
    return 237;
  v6[0] = a2 != 0;
  v6[1] = a1;
  v6[2] = a4;
  v10 = 0;
  if ( !sub_10001E70(v9, 48, 3u, (int)v6) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 11, v9) != 11 )
    return 2;
  if ( !sub_10001AA0(v7, 2000) )
    return 8;
  if ( sub_10001FF0((int)v7) )
    return sub_10002BD0((int)v7);
  if ( v7[1] != 82 )
    return 10;
  for ( i = 0; i < a4; ++i )
    *(_BYTE *)(i + a3) = v7[i + 8];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10003A90) --------------------------------------------------------
int __cdecl I2CLtWriteBlock(__int16 a1, __int16 a2, int a3, __int16 a4)
{
  char v5[264]; // [esp+0h] [ebp-220h] BYREF
  int i; // [esp+108h] [ebp-118h]
  int v7; // [esp+10Ch] [ebp-114h]
  char v8[264]; // [esp+110h] [ebp-110h] BYREF
  int v9; // [esp+21Ch] [ebp-4h]

  v7 = 0;
  v5[0] = a2 != 0;
  v5[1] = a1;
  v5[2] = a4;
  if ( !sub_10005EC0() )
    return 237;
  v9 = 0;
  for ( i = 0; i < a4; ++i )
    v5[i + 3] = *(_BYTE *)(i + a3);
  if ( !sub_10001E70(v8, 49, a4 + 3, (int)v5) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, a4 + 11, v8) == a4 + 11 )
    return sub_10001C10();
  else
    return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10003BC0) --------------------------------------------------------
int I2CLtStop()
{
  char v1[4]; // [esp+0h] [ebp-18h] BYREF
  char v2[16]; // [esp+4h] [ebp-14h] BYREF

  v1[0] = 0;
  if ( !sub_10005EC0() )
    return 237;
  if ( !sub_10001E70(v2, 50, 1u, (int)v1) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 9, v2) == 9 )
    return 0;
  else
    return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10003BC0: using guessed type char var_18[4];

//----- (10003C40) --------------------------------------------------------
int __cdecl sub_10003C40(_DWORD *a1, _DWORD *a2)
{
  char v3[264]; // [esp+0h] [ebp-218h] BYREF
  char v4[268]; // [esp+108h] [ebp-110h] BYREF

  if ( !sub_10001E70(v4, 128, 0, 0) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 8, v4) != 8 )
    return 2;
  if ( !sub_10001AA0(v3, 2000) )
    return 8;
  if ( sub_10001FF0((int)v3) )
    return sub_10002BD0((int)v3);
  if ( (unsigned __int8)v3[1] != 192 )
    return 10;
  *a1 = (unsigned __int8)v3[7] + ((unsigned __int8)v3[6] << 8);
  *a2 = (unsigned __int8)v3[8];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10003D40) --------------------------------------------------------
int __cdecl I2CLtSetTiming(char a1, char a2, char a3, char a4, __int16 a5)
{
  char v6[8]; // [esp+0h] [ebp-2Ch] BYREF
  char v7[28]; // [esp+8h] [ebp-24h] BYREF
  int v8; // [esp+28h] [ebp-4h]

  if ( !sub_10005EC0() )
    return 237;
  v6[0] = a1;
  v6[1] = a2;
  v6[2] = a3;
  v6[3] = a4;
  v6[4] = (unsigned __int16)(a5 & 0xFF00) >> 8;
  v6[5] = a5;
  v8 = 0;
  if ( !sub_10001E70(v7, 187, 6u, (int)v6) )
    return 9;
  if ( PutPacket(0, 14, v7) == 14 )
    return sub_10001C10();
  return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10003E10) --------------------------------------------------------
int __cdecl GetAdapterFWVersion(char *Buffer)
{
  int v2; // [esp+10h] [ebp-24h] BYREF
  char Source; // [esp+14h] [ebp-20h] BYREF
  int v4[4]; // [esp+15h] [ebp-1Fh] BYREF
  __int16 v5; // [esp+25h] [ebp-Fh]
  char v6; // [esp+27h] [ebp-Dh]
  int v7; // [esp+2Ch] [ebp-8h]
  int v8; // [esp+30h] [ebp-4h] BYREF

  v8 = 0;
  v2 = 0;
  Source = 0;
  memset(v4, 0, sizeof(v4));
  v5 = 0;
  v6 = 0;
  *(_WORD *)Buffer = 0;
  v7 = sub_10003C40(&v8, &v2);
  if ( v7 )
    return v7;
  if ( sub_10005EC0() )
  {
    sprintf(Buffer, "%0.1d.%0.2d", BYTE1(v8), (unsigned __int8)v8);
  }
  else
  {
    sprintf(&Source, "%c.%c%c", BYTE1(v8), (unsigned __int8)v8, (unsigned __int8)v2);
    strcpy_s(Buffer, (char *)v4 + strlen(&Source) - (char *)v4 + 1, &Source);
  }
  return v7;
}

//----- (10003F30) --------------------------------------------------------
int __cdecl GPIOWrite(__int16 a1, __int16 a2)
{
  char v3[268]; // [esp+0h] [ebp-110h] BYREF

  a2 = ((unsigned __int8)a1 << 8) | (unsigned __int8)a2;
  if ( !sub_10001E70(v3, 147, 2u, (int)&a2) )
    return 9;
  if ( PutPacket(0, 10, v3) == 10 )
    return 0;
  return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10003FC0) --------------------------------------------------------
int __cdecl GPIORead(char a1, _WORD *a2)
{
  char v3[264]; // [esp+0h] [ebp-218h] BYREF
  char v4[268]; // [esp+108h] [ebp-110h] BYREF

  if ( !sub_10001E70(v4, 148, 1u, (int)&a1) )
    return 9;
  if ( PutPacket(0, 9, v4) != 9 )
    return 2;
  if ( !sub_10001AA0(v3, 2000) )
    return 8;
  if ( sub_10001FF0((int)v3) )
    return sub_10002BD0((int)v3);
  if ( (unsigned __int8)v3[1] != 202 )
    return 10;
  *a2 = (unsigned __int8)v3[6];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (100040A0) --------------------------------------------------------
int __cdecl sub_100040A0(char a1, char *a2, char *a3)
{
  char v4[264]; // [esp+0h] [ebp-318h] BYREF
  char v5[264]; // [esp+108h] [ebp-210h] BYREF
  char v6; // [esp+210h] [ebp-108h] BYREF
  char v7; // [esp+211h] [ebp-107h]
  char v8; // [esp+212h] [ebp-106h]
  char v9; // [esp+213h] [ebp-105h]
  char v10; // [esp+214h] [ebp-104h]
  char v11; // [esp+215h] [ebp-103h]
  char v12; // [esp+216h] [ebp-102h]

  if ( a1 )
  {
    v6 = 1;
    v7 = 0;
    v8 = *a2;
    v9 = 0;
    v10 = a2[1];
    v11 = 0;
    v12 = a2[2];
    if ( sub_10001E70(v5, 183, 7u, (int)&v6) )
    {
      if ( PutPacket(0, 15, v5) == 15 )
      {
        if ( sub_10001AA0(v4, 2000) )
        {
          if ( sub_10001FF0((int)v4) )
          {
            return sub_10002BD0((int)v4);
          }
          else if ( (unsigned __int8)v4[1] == 202 )
          {
            *a3 = v4[7];
            a3[1] = v4[9];
            a3[2] = v4[11];
            return 0;
          }
          else
          {
            return 10;
          }
        }
        else
        {
          return 8;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 9;
    }
  }
  else
  {
    v6 = 0;
    v7 = *a3;
    v8 = *a2;
    v9 = a3[1];
    v10 = a2[1];
    v11 = a3[2];
    v12 = a2[2];
    if ( sub_10001E70(v5, 183, 7u, (int)&v6) )
    {
      if ( PutPacket(0, 15, v5) == 15 )
        return 0;
      else
        return 2;
    }
    else
    {
      return 9;
    }
  }
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10004290) --------------------------------------------------------
int __cdecl GetEV2300Name(_BYTE *a1, _DWORD *a2)
{
  char v3; // [esp+Bh] [ebp-389h]
  _BYTE *v4; // [esp+10h] [ebp-384h]
  char *v5; // [esp+14h] [ebp-380h]
  char *v7; // [esp+1Ch] [ebp-378h]
  char *v8; // [esp+30h] [ebp-364h]
  int j; // [esp+34h] [ebp-360h]
  int i; // [esp+38h] [ebp-35Ch]
  char v11[5]; // [esp+3Ch] [ebp-358h] BYREF
  unsigned __int8 v12; // [esp+41h] [ebp-353h]
  int SerialNumberString; // [esp+144h] [ebp-250h]
  char *v14; // [esp+148h] [ebp-24Ch] BYREF
  char String2[4]; // [esp+14Ch] [ebp-248h] BYREF
  int v16; // [esp+150h] [ebp-244h]
  int v17; // [esp+154h] [ebp-240h]
  int v18; // [esp+158h] [ebp-23Ch]
  int v19; // [esp+15Ch] [ebp-238h]
  int v20; // [esp+160h] [ebp-234h]
  int v21; // [esp+164h] [ebp-230h]
  int v22; // [esp+168h] [ebp-22Ch]
  int v23; // [esp+16Ch] [ebp-228h]
  char v24; // [esp+173h] [ebp-221h] BYREF
  char v25[268]; // [esp+174h] [ebp-220h] BYREF
  int v26; // [esp+280h] [ebp-114h]
  char Buffer[4]; // [esp+284h] [ebp-110h] BYREF
  int v28; // [esp+288h] [ebp-10Ch]
  char String1[260]; // [esp+28Ch] [ebp-108h] BYREF

  v23 = 0;
  v26 = 6;
  v28 = 0;
  v24 = 0;
  if ( !sub_10001E70(v25, 144, 1u, (int)&v24) )
    return 9;
  if ( PutPacket(0, 9, v25) != 9 )
    return 2;
  if ( !sub_10001AA0(v11, 2000) )
    return 8;
  if ( sub_10001FF0((int)v11) )
    return sub_10002BD0((int)v11);
  if ( (unsigned __int8)v11[1] != 200 )
    return 10;
  *a2 = (unsigned __int8)v11[v26];
  if ( v12 == 8 )
  {
    if ( sub_10005EC0() )
    {
      *(_DWORD *)String2 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v14 = String2;
      for ( i = 0; i < v12; ++i )
      {
        sprintf(Buffer, "%02X", (unsigned __int8)v11[i + v26]);
        v8 = &Buffer[strlen(Buffer) + 1];
        v7 = (char *)&v14 + 3;
        while ( *++v7 )
          ;
        qmemcpy(v7, Buffer, v8 - Buffer);
      }
      SerialNumberString = GetSerialNumberString_(String1, 256);
      if ( !SerialNumberString )
      {
        SerialNumberString = stricmp(String1, String2);
        if ( !SerialNumberString )
        {
          v5 = String2;
          v4 = a1;
          do
          {
            v3 = *v5;
            *v4++ = *v5++;
          }
          while ( v3 );
          *a2 = 17;
          v28 = 1;
        }
      }
    }
  }
  if ( v28 == 0 )
  {
    for ( j = 0; j < *a2; ++j )
      a1[j] = v11[v26 + 1 + j];
  }
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10004290: using guessed type char Buffer[4];

//----- (10004630) --------------------------------------------------------
int __cdecl SetEV2300Name(int a1, int a2)
{
  int v3; // eax
  int i; // [esp+0h] [ebp-220h]
  unsigned __int8 v5[264]; // [esp+8h] [ebp-218h] BYREF
  char v6[268]; // [esp+110h] [ebp-110h] BYREF

  if ( a2 > 100 )
    return 7;
  v5[0] = a2;
  for ( i = 0; i < a2; ++i )
    v5[i + 1] = *(_BYTE *)(i + a1);
  if ( !sub_10001E70(v6, 144, v5[0], (int)v5) )
    return 9;
  v3 = PutPacket(0, v5[0] + 9, v6);
  if ( v3 != v5[0] + 9 )
    return 2;
  Sleep(0x64u);
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10004730) --------------------------------------------------------
int __cdecl SetTUSBCharacteristic1(__int16 a1, __int16 a2)
{
  int v3; // eax
  int i; // [esp+0h] [ebp-21Ch]
  char v5[264]; // [esp+4h] [ebp-218h] BYREF
  char v6[264]; // [esp+10Ch] [ebp-110h] BYREF
  int v7; // [esp+218h] [ebp-4h]

  for ( i = 0; i < 52; ++i )
    v5[i] = 0;
  v5[0] = a1;
  v5[1] = a2;
  if ( !sub_10001E70(v6, 189, 2u, (int)v5) )
    return 9;
  v7 = 10;
  v3 = PutPacket(0, 10, v6);
  if ( v3 == v7 )
    return 0;
  else
    return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10004800) --------------------------------------------------------
int __cdecl GPIOSetup(int a1, __int16 N)
{
  int i; // [esp+0h] [ebp-220h]
  char v4[264]; // [esp+8h] [ebp-218h] BYREF
  char v5[268]; // [esp+110h] [ebp-110h] BYREF

  if ( N != 1 )
    return 7;
  for ( i = 0; i < N; ++i )
    v5[i] = *(_BYTE *)(i + a1);
  if ( !sub_10001E70(v4, 182, 3u, (int)v5) )
    return 9;
  if ( PutPacket(0, 11, v4) == 11 )
    return 0;
  return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10004800: using guessed type char var_110[268];

//----- (100048D0) --------------------------------------------------------
int __cdecl GPIOWriteRead(int a1, __int16 *a2)
{
  int j; // [esp+0h] [ebp-32Ch]
  char v4[264]; // [esp+4h] [ebp-328h] BYREF
  int i; // [esp+10Ch] [ebp-220h]
  int v6; // [esp+110h] [ebp-21Ch]
  char v7[264]; // [esp+114h] [ebp-218h] BYREF
  unsigned __int8 v8[264]; // [esp+21Ch] [ebp-110h] BYREF
  __int16 v9; // [esp+328h] [ebp-4h]

  v6 = 0;
  v9 = *a2;
  for ( i = 0; i < v9; ++i )
    v8[i] = *(_BYTE *)(i + v6);
  if ( !sub_10001E70(v7, 182, 4u, (int)v8) )
    return 9;
  if ( PutPacket(0, 12, v7) != 12 )
    return 2;
  if ( v8[0] != 1 || !sub_10001AA0(v4, 2000) )
    return 0;
  if ( sub_10001FF0((int)v4) )
    return sub_10002BD0((int)v4);
  if ( (unsigned __int8)v4[1] != 204 )
    return 10;
  *a2 = (unsigned __int8)v4[6];
  for ( j = 0; j < *a2; ++j )
    *(_BYTE *)(j + a1) = v4[j + 7];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 100048D0: using guessed type unsigned __int8 var_110[264];

//----- (10004A60) --------------------------------------------------------
bool sub_10004A60()
{
  int v1; // [esp+0h] [ebp-Ch] BYREF
  int v2; // [esp+4h] [ebp-8h]
  int v3; // [esp+8h] [ebp-4h] BYREF

  Sleep(5u);
  v2 = sub_10003C40(&v3, &v1);
  return !v2 && v3 == 13105;
}

//----- (10004AA0) --------------------------------------------------------
int __cdecl SetPinVoltage(__int16 a1, __int16 a2)
{
  int result; // eax
  bool v3; // [esp+7h] [ebp-15h]
  char v4; // [esp+8h] [ebp-14h] BYREF
  char v5; // [esp+9h] [ebp-13h]
  char v6; // [esp+Ah] [ebp-12h]
  __int16 v7; // [esp+Ch] [ebp-10h]
  __int16 v8; // [esp+10h] [ebp-Ch] BYREF
  BOOL v9; // [esp+14h] [ebp-8h]
  char v10; // [esp+18h] [ebp-4h] BYREF
  char v11; // [esp+19h] [ebp-3h]
  char v12; // [esp+1Ah] [ebp-2h]

  v3 = sub_10004A60();
  v9 = sub_10005EC0();
  v7 = a2 != 0;
  switch ( a1 )
  {
    case 1:
      if ( v3 )
      {
        result = sub_10002970(0, v7, 0, &v8);
      }
      else if ( v9 )
      {
        v4 = 0;
        v5 = 0;
        v6 = 64;
        v10 = 0;
        v11 = 0;
        v12 = v7 != 0 ? 0x40 : 0;
        result = sub_100040A0(0, &v4, &v10);
      }
      else
      {
        result = 53;
      }
      break;
    case 2:
      if ( v3 )
        goto LABEL_8;
      if ( v9 )
      {
        v4 = 0;
        v5 = 0;
        v6 = 0x80;
        v10 = 0;
        v11 = 0;
        v12 = v7 != 0 ? 0x80 : 0;
        result = sub_100040A0(0, &v4, &v10);
      }
      else
      {
        result = 53;
      }
      break;
    case 3:
      if ( v3 )
LABEL_8:
        result = sub_10002970(3, v7 != 0 ? 3 : 0, 0, &v8);
      else
        result = 53;
      break;
    case 4:
      if ( v3 )
      {
        result = GPIOWrite(32, (unsigned __int8)-(v7 != 0));
      }
      else if ( v9 )
      {
        v4 = 0;
        v5 = 0x80;
        v6 = 0;
        v10 = 0;
        v11 = v7 != 0 ? 0x80 : 0;
        v12 = 0;
        result = sub_100040A0(0, &v4, &v10);
      }
      else
      {
        result = 53;
      }
      break;
    default:
      result = 53;
      break;
  }
  return result;
}

//----- (10004CA0) --------------------------------------------------------
int __cdecl SetVVODVoltage(__int16 a1, __int16 a2)
{
  char v3[4]; // [esp+0h] [ebp-18h] BYREF
  char v4[12]; // [esp+4h] [ebp-14h] BYREF
  int v5; // [esp+14h] [ebp-4h]

  v3[0] = a1;
  v3[1] = a2;
  v5 = 0;
  if ( !sub_10001E70(v4, 179, 2u, (int)v3) )
    return 9;
  if ( PutPacket(0, 10, v4) != 10 )
    return 2;
  sub_10001940();
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10004D30) --------------------------------------------------------
int __cdecl GetVVODVoltage(char a1, _WORD *a2)
{
  char v3[264]; // [esp+0h] [ebp-218h] BYREF
  char v4[268]; // [esp+108h] [ebp-110h] BYREF

  if ( !sub_10001E70(v4, 180, 1u, (int)&a1) )
    return 9;
  if ( PutPacket(0, 10, v4) != 10 )
    return 2;
  if ( !sub_10001AA0(v3, 2000) )
    return 8;
  if ( sub_10001FF0((int)v3) )
    return sub_10002BD0((int)v3);
  if ( (unsigned __int8)v3[1] != 205 )
    return 10;
  *a2 = (unsigned __int8)v3[6];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10004E10) --------------------------------------------------------
int __cdecl sub_10004E10(__int16 a1, int a2, __int16 a3)
{
  int i; // [esp+0h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-4h]

  for ( i = 0; i < a3; ++i )
  {
    v5 = HDQ8WriteByte(i + a1, *(unsigned __int8 *)(i + a2));
    if ( v5 )
      return v5;
    Sleep(0x1Eu);
  }
  return v5;
}
// 10004E6C: variable 'v5' is possibly undefined

//----- (10004E80) --------------------------------------------------------
int __cdecl sub_10004E80(__int16 a1, int a2, __int16 a3)
{
  int i; // [esp+0h] [ebp-Ch]
  __int16 v5; // [esp+4h] [ebp-8h] BYREF
  int v6; // [esp+8h] [ebp-4h]

  for ( i = 0; i < a3; ++i )
  {
    if ( !i )
      a1 |= 0x80u;
    v6 = HDQ8ReadByte(i + a1, &v5);
    if ( v6 )
    {
      v6 = HDQ8ReadByte(a1 + i + 128, &v5);
      if ( v6 )
        return v6;
    }
    else
    {
      *(_BYTE *)(i + a2) = v5;
    }
    if ( !i )
      a1 &= 0x7Fu;
  }
  return v6;
}

//----- (10004F30) --------------------------------------------------------
int __cdecl HDQ8ReadBlock(__int16 a1, int a2, __int16 a3)
{
  int result; // eax
  int v4; // eax
  int i; // [esp+0h] [ebp-32Ch]
  char v6[264]; // [esp+4h] [ebp-328h] BYREF
  char v7[264]; // [esp+10Ch] [ebp-220h] BYREF
  int v8; // [esp+214h] [ebp-118h]
  int v9; // [esp+218h] [ebp-114h]
  char v10[264]; // [esp+21Ch] [ebp-110h] BYREF
  unsigned __int8 v11; // [esp+32Bh] [ebp-1h]

  v8 = 0;
  v9 = 0;
  if ( sub_10005EC0() )
  {
    v6[0] = a1;
    v6[1] = a3;
    v11 = 10;
    if ( sub_10001E70(v10, 47, 2u, (int)v6) )
    {
      v4 = PutPacket(0, v11, v10);
      if ( v4 == v11 )
      {
        if ( sub_10001AA0(v7, 2000) )
        {
          if ( sub_10001FF0((int)v7) )
          {
            return sub_10002BD0((int)v7);
          }
          else if ( v7[1] == 91 )
          {
            for ( i = 0; i < a3; ++i )
              *(_BYTE *)(i + a2) = v7[i + 7];
            return 0;
          }
          else
          {
            return 10;
          }
        }
        else
        {
          return 8;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 9;
    }
  }
  else
  {
    result = sub_10004E80(a1, a2, a3);
    v9 = result;
  }
  return result;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (100050D0) --------------------------------------------------------
int __cdecl HDQ8WriteBlock(__int16 a1, int a2, __int16 a3)
{
  int result; // eax
  int v4; // eax
  int i; // [esp+0h] [ebp-22Ch]
  char v6; // [esp+4h] [ebp-228h] BYREF
  unsigned __int8 v7; // [esp+5h] [ebp-227h]
  char v8[262]; // [esp+6h] [ebp-226h]
  int v9; // [esp+10Ch] [ebp-120h]
  int v10; // [esp+110h] [ebp-11Ch]
  char v11[268]; // [esp+114h] [ebp-118h] BYREF
  int v12; // [esp+224h] [ebp-8h]
  int v13; // [esp+228h] [ebp-4h]

  v9 = 0;
  if ( sub_10005EC0() )
  {
    v6 = a1;
    v7 = a3;
    for ( i = 0; i < a3; ++i )
      v8[i] = *(_BYTE *)(i + a2);
    v12 = 0;
    if ( sub_10001E70(v11, 45, v7 + 2, (int)&v6) )
    {
      v13 = v7 + 10;
      v4 = PutPacket(0, v13, v11);
      if ( v4 == v13 )
        return sub_10001C10();
      else
        return 2;
    }
    else
    {
      return 9;
    }
  }
  else
  {
    result = sub_10004E10(a1, a2, a3);
    v10 = result;
  }
  return result;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 100050D0: using guessed type char var_226[262];

//----- (10005200) --------------------------------------------------------
int HDQSendBreak()
{
  char v1; // [esp+0h] [ebp-10h] BYREF
  char v2[11]; // [esp+1h] [ebp-Fh] BYREF

  v1 = -86;
  strcpy(v2, "-");
  v2[2] = 0;
  v2[3] = 0;
  v2[4] = 4;
  v2[5] = 0x80;
  v2[6] = 0;
  v2[7] = 2;
  v2[8] = 0;
  v2[9] = -62;
  v2[10] = 85;
  if ( sub_10005EC0() )
    return PutPacket(0, 12, &v1);
  else
    return sub_10002E00(4, 0, 0);
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10005280) --------------------------------------------------------
int __cdecl SetEV2400CommClkSpeed(__int16 a1, __int16 a2)
{
  char v3; // [esp+4h] [ebp-118h] BYREF
  char v4; // [esp+5h] [ebp-117h]
  int v5; // [esp+8h] [ebp-114h]
  char v6[268]; // [esp+Ch] [ebp-110h] BYREF

  if ( (unsigned int)a2 >= 2 )
    return 7;
  v5 = 4000 / a1;
  if ( a2 )
  {
    if ( a2 == 1 )
    {
      v4 = (unsigned __int16)(v5 & 0xFF00) >> 8;
      v3 = v5;
      if ( !sub_10001E70(v6, 238, 2u, (int)&v3) )
        return 9;
    }
  }
  else
  {
    v4 = (unsigned __int16)(v5 & 0xFF00) >> 8;
    v3 = v5;
    if ( !sub_10001E70(v6, 239, 2u, (int)&v3) )
      return 9;
  }
  if ( PutPacket(0, 10, v6) != 10 )
    return 2;
  sub_10001940();
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (100053C0) --------------------------------------------------------
int __cdecl UseAardvarkSPI(int a1)
{
  dword_1002BD34 = a1;
  return 0;
}
// 1002BD34: using guessed type int dword_1002BD34;

//----- (100053D0) --------------------------------------------------------
int __cdecl SPI16ReadBlock(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  int i; // [esp+0h] [ebp-334h]
  char v5[264]; // [esp+4h] [ebp-330h] BYREF
  char v6[268]; // [esp+10Ch] [ebp-228h] BYREF
  int v7; // [esp+218h] [ebp-11Ch]
  char v8[264]; // [esp+21Ch] [ebp-118h] BYREF
  int v9; // [esp+328h] [ebp-Ch]
  __int16 v10; // [esp+32Ch] [ebp-8h]
  char v11; // [esp+333h] [ebp-1h]

  v7 = 0;
  v11 = 8;
  v10 = 0;
  if ( dword_1002BD34 == 1 )
    return sub_10001490(a1, a2, a3);
  v5[0] = a1;
  v5[1] = a3;
  v9 = 0;
  if ( !sub_10001E70(v8, 209, 2u, (int)v5) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 10, v8) != 10 )
    return 2;
  if ( !sub_10001AA0(v6, 2000) )
    return 8;
  if ( sub_10001FF0((int)v6) )
    return sub_10002BD0((int)v6);
  if ( (unsigned __int8)v6[1] != 209 )
    return 10;
  for ( i = 0; i < a3; ++i )
    *(_BYTE *)(i + a2) = v6[i + 7];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 1002BD34: using guessed type int dword_1002BD34;

//----- (10005560) --------------------------------------------------------
int __cdecl SPI16WriteBlock(unsigned __int8 a1, char *a2, unsigned __int8 a3)
{
  char v4[264]; // [esp+0h] [ebp-220h] BYREF
  int i; // [esp+108h] [ebp-118h]
  int v6; // [esp+10Ch] [ebp-114h]
  char v7[264]; // [esp+110h] [ebp-110h] BYREF
  int v8; // [esp+21Ch] [ebp-4h]

  v6 = 0;
  if ( dword_1002BD34 == 1 )
    return sub_10001430(a1, a2, a3);
  v4[0] = a1;
  v4[1] = a3;
  v8 = 0;
  for ( i = 0; i < a3; ++i )
    v4[i + 2] = a2[i];
  if ( !sub_10001E70(v7, 211, a3 + 2, (int)v4) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, a3 + 10, v7) == a3 + 10 )
    return sub_10001C10();
  else
    return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 1002BD34: using guessed type int dword_1002BD34;

//----- (10005690) --------------------------------------------------------
int __cdecl SPIConfigure(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
  char v5[264]; // [esp+0h] [ebp-218h] BYREF
  char v6[268]; // [esp+108h] [ebp-110h] BYREF

  v5[0] = HIBYTE(a3);
  v5[1] = a3;
  v5[2] = a2;
  v5[3] = a1;
  v5[4] = 1;
  v5[5] = 0;
  v5[6] = a4;
  if ( !sub_10001E70(v6, 178, 7u, (int)v5) )
    return 9;
  if ( PutPacket(0, 15, v6) != 15 )
    return 2;
  sub_10001940();
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10005760) --------------------------------------------------------
int __cdecl SPIReadConfiguration(_WORD *a1, _WORD *a2, _DWORD *a3, _WORD *a4)
{
  char v5[264]; // [esp+0h] [ebp-328h] BYREF
  char v6[6]; // [esp+108h] [ebp-220h] BYREF
  unsigned __int8 v7; // [esp+10Eh] [ebp-21Ah]
  unsigned __int8 v8; // [esp+10Fh] [ebp-219h]
  unsigned __int8 v9; // [esp+110h] [ebp-218h]
  unsigned __int8 v10; // [esp+111h] [ebp-217h]
  unsigned __int8 v11; // [esp+114h] [ebp-214h]
  char v12[268]; // [esp+210h] [ebp-118h] BYREF
  int v13; // [esp+320h] [ebp-8h]
  int v14; // [esp+324h] [ebp-4h]

  v5[0] = 0;
  if ( !sub_10001E70(v12, 210, 1u, (int)v5) )
    return 9;
  sub_10001940();
  if ( PutPacket(0, 9, v12) != 9 )
    return 2;
  if ( !sub_10001AA0(v6, 2000) )
    return 8;
  if ( sub_10001FF0((int)v6) )
    return sub_10002BD0((int)v6);
  if ( (unsigned __int8)v6[1] != 210 )
    return 10;
  v13 = v7;
  v14 = v8;
  *a3 = v8 + (unsigned __int16)(v7 << 8);
  *a2 = v9;
  *a1 = v10;
  *a4 = v11;
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 10005760: using guessed type char var_328[264];

//----- (100058A0) --------------------------------------------------------
int __cdecl GetBoardType(__int16 *a1, int a2)
{
  int v3; // eax
  int i; // [esp+0h] [ebp-21Ch]
  char v5[264]; // [esp+4h] [ebp-218h] BYREF
  char v6[264]; // [esp+10Ch] [ebp-110h] BYREF
  int v7; // [esp+218h] [ebp-4h]

  if ( !sub_10001E70(v6, 150, 0, a2) )
    return 9;
  v7 = 8;
  v3 = PutPacket(0, 8, v6);
  if ( v3 != v7 )
    return 2;
  if ( !sub_10001AA0(v5, 2000) )
    return 8;
  if ( sub_10001FF0((int)v5) )
    return sub_10002BD0((int)v5);
  if ( (unsigned __int8)v5[1] != 207 )
    return 10;
  *a1 = (unsigned __int8)v5[5];
  for ( i = 0; i < *a1; ++i )
    *(_BYTE *)(i + a2) = v5[i + 6];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (100059D0) --------------------------------------------------------
int __cdecl SetVoutWithTimeout(char a1, char a2, char a3, char a4)
{
  char v5[4]; // [esp+0h] [ebp-24h] BYREF
  char v6[28]; // [esp+4h] [ebp-20h] BYREF

  if ( !sub_10005EC0() )
    return 237;
  v5[0] = a1;
  v5[1] = a2;
  v5[2] = a3;
  v5[3] = a4;
  if ( !sub_10001E70(v6, 188, 4u, (int)v5) )
    return 9;
  if ( PutPacket(0, 12, v6) == 12 )
    return sub_10001C10();
  return 2;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10005A80) --------------------------------------------------------
int __cdecl SetPWMConfig(__int16 a1)
{
  char v2[4]; // [esp+0h] [ebp-28h] BYREF
  __int16 v3; // [esp+4h] [ebp-24h]
  char v4[28]; // [esp+8h] [ebp-20h] BYREF

  v3 = 10000;
  if ( !sub_10005EC0() )
    return 237;
  if ( a1 )
  {
    v2[0] = a1;
    v2[1] = (unsigned __int16)(a1 & 0xFF00) >> 8;
    v2[2] = v3;
    v2[3] = (unsigned __int16)(v3 & 0xFF00) >> 8;
    if ( !sub_10001E70(v4, 154, 4u, (int)v2) )
      return 9;
    if ( PutPacket(0, 12, v4) != 12 )
      return 2;
  }
  else
  {
    if ( !sub_10001E70(v4, 154, 0, 0) )
      return 9;
    if ( PutPacket(0, 8, v4) != 8 )
      return 2;
  }
  return sub_10001C10();
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (10005B90) --------------------------------------------------------
FILE *__cdecl sub_10005B90(int a1, const char *a2, __int16 a3, __int16 a4, unsigned __int8 *a5)
{
  FILE *result; // eax
  int i; // [esp+4h] [ebp-60h]
  FILE *Stream; // [esp+8h] [ebp-5Ch]
  char Buffer[68]; // [esp+Ch] [ebp-58h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+50h] [ebp-14h] BYREF

  memset(Buffer, 0, 64);
  result = fopen(&FileName, "a");
  Stream = result;
  if ( result )
  {
    if ( a4 <= 256 )
    {
      GetLocalTime(&SystemTime);
      sprintf(
        Buffer,
        "%04d-%02d-%02d %02d:%02d:%02d:%03d ",
        SystemTime.wYear,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond,
        SystemTime.wMilliseconds);
      fprintf(Stream, "%s %s ", Buffer, a2);
      fprintf(Stream, "<%02X> ", a3);
      if ( a4 )
      {
        for ( i = 0; i < a4; ++i )
          fprintf(Stream, "%02x ", *a5++);
        fprintf(Stream, "\n");
      }
      else
      {
        fprintf(Stream, "\n");
      }
      return (FILE *)fclose(Stream);
    }
    else
    {
      return (FILE *)fclose(result);
    }
  }
  return result;
}

//----- (10005D00) --------------------------------------------------------
int __cdecl StartCommLogging(char *Source)
{
  FILE *Stream; // [esp+34h] [ebp-4h]

  if ( !strlen(Source) )
    return 801;
  if ( strlen(Source) > 0xFE )
    return 1453;
  strcpy_s(&FileName, strlen(Source) + 1, Source);
  Stream = fopen(&FileName, "w");
  if ( !Stream )
    return 1421;
  if ( fprintf(Stream, "* Computer to slave communication transactions.\n*\n") < 0
    || fprintf(Stream, "*Format: \"TimeStamp\" \"Internal Function Name\" \"<TargetAddress>\" \"Data\"\n*\n") < 0 )
  {
    fclose(Stream);
    return 1421;
  }
  else
  {
    fprintf(Stream, "*Begin Logging\n");
    fclose(Stream);
    return 0;
  }
}

//----- (10005E70) --------------------------------------------------------
void StopCommLogging()
{
  FileName = 0;
}

//----- (10005E80) --------------------------------------------------------
int __cdecl OpenDeviceBySerial_(char *a1)
{
  return OpenDeviceBySerial(a1);
}
// 1000F0F8: using guessed type _DWORD __cdecl OpenDeviceBySerial(char *);

//----- (10005EA0) --------------------------------------------------------
int __cdecl GetSerialNumberString_(char *a1, __int16 a2)
{
  return GetSerialNumberString(a1, a2);
}
// 1000F0EC: using guessed type _DWORD __cdecl GetSerialNumberString(char *, __int16);

//----- (10005EC0) --------------------------------------------------------
BOOL sub_10005EC0()
{
  return IsDeviceConnected() && !sub_10004A60();
}
// 1000F0FC: using guessed type bool __cdecl IsDeviceConnected();

//----- (10005F10) --------------------------------------------------------
unsigned int __cdecl sub_10005F10(int a1)
{
  unsigned int v2; // [esp+4h] [ebp-4h]

  switch ( a1 )
  {
    case 0:
      v2 = 2;
      break;
    case 1:
      v2 = 2;
      break;
    case 2:
      v2 = 2;
      break;
    case 3:
      v2 = 1;
      break;
    case 4:
      v2 = 1;
      break;
    case 5:
      v2 = 1;
      break;
    case 6:
      v2 = 4;
      break;
    default:
      v2 = a1 & 0xFFFFFF7F;
      break;
  }
  return v2;
}

//----- (10005FA0) --------------------------------------------------------
int __cdecl sub_10005FA0(int a1, int a2, int a3, unsigned int a4)
{
  int v5; // [esp+0h] [ebp-8h]
  unsigned int v6; // [esp+4h] [ebp-4h]

  v6 = 0;
  v5 = 0;
  while ( v6 < a4 )
  {
    if ( *(_BYTE *)(v6 + a1) == 34 )
    {
      *(_DWORD *)(a2 + 4 * v5++) = v6;
    }
    else if ( *(_BYTE *)(v6 + a1) == 10 )
    {
      return v5;
    }
    ++v6;
  }
  return v5;
}

//----- (10006010) --------------------------------------------------------
int __cdecl sub_10006010(int a1, _BYTE *a2, int a3, int a4)
{
  if ( *(_BYTE *)(a3 + a1) != 34 )
    return 229;
  if ( *(_BYTE *)(a4 + a1) != 34 )
    return 229;
  sub_10006E10((_BYTE *)(a1 + a3 + 1), a2, a4 - a3 - 1);
  a2[a4 - a3 - 1] = 0;
  return 0;
}

//----- (10006070) --------------------------------------------------------
int __cdecl sub_10006070(char *Buffer)
{
  long double v1; // st7
  long double v2; // st7
  int v4; // [esp+20h] [ebp-2Ch]
  long double v5; // [esp+24h] [ebp-28h] BYREF
  char v6; // [esp+33h] [ebp-19h]
  char v7[8]; // [esp+34h] [ebp-18h] BYREF
  long double v8; // [esp+3Ch] [ebp-10h]
  char *v9; // [esp+48h] [ebp-4h]

  v8 = 1.0e-38;
  v6 = 0;
  v9 = v7;
  if ( sscanf(Buffer, "%lf", &v5) != 1 )
    return -1;
  if ( v5 < 0.0 )
  {
    v6 = 0x80;
    v5 = -v5;
  }
  if ( v8 > v5 || v5 > 1.0e38 )
    return -1;
  v4 = (int)(log(v5) / log(2.0) + 1.0 + 128.0);
  v1 = ldexpl(0.5, v4 - 152);
  v2 = v1 * v5;
  *v9++ = v4;
  *v9++ = v6 | ((unsigned int)(int)v2 >> 16) & 0x7F;
  *v9++ = (unsigned __int16)(int)v2 >> 8;
  *v9++ = (int)v2;
  sub_10006E10(v7, Buffer, 4);
  return 0;
}

//----- (100061B0) --------------------------------------------------------
int __cdecl sub_100061B0(char *Buffer)
{
  int result; // eax
  int v2; // eax
  unsigned __int8 v3; // al
  char v4[400]; // [esp+14h] [ebp-198h] BYREF
  unsigned __int8 v5; // [esp+1ABh] [ebp-1h]

  switch ( *((_DWORD *)Buffer + 96) )
  {
    case 0:
      sscanf(Buffer, "%d", v4);
      goto LABEL_14;
    case 1:
      sscanf(Buffer, "%u", v4);
      goto LABEL_14;
    case 2:
      sscanf(Buffer, "%X", v4);
      goto LABEL_14;
    case 3:
      sscanf(Buffer, "%d", v4);
      goto LABEL_14;
    case 4:
      sscanf(Buffer, "%u", v4);
      goto LABEL_14;
    case 5:
      sscanf(Buffer, "%02X", v4);
LABEL_14:
      v2 = sub_10005F10(*((_DWORD *)Buffer + 96));
      sub_10006E10(v4, Buffer, v2);
      v3 = sub_10005F10(*((_DWORD *)Buffer + 96));
      sub_10006EF0(Buffer, v3);
      result = 0;
      break;
    case 6:
      sub_10006070(Buffer);
      result = 0;
      break;
    default:
      if ( *((int *)Buffer + 96) < 128 )
      {
        result = -1;
      }
      else
      {
        v5 = strlen(Buffer);
        sub_10006E10(Buffer, Buffer + 1, v5);
        if ( (*((_DWORD *)Buffer + 96) & 0x7F) != 0 )
          *Buffer = v5;
        result = 0;
      }
      break;
  }
  return result;
}
// 100061B0: using guessed type char var_198[400];

//----- (100063D0) --------------------------------------------------------
int __cdecl sub_100063D0(FILE *Stream, char *a2)
{
  unsigned __int8 v3; // [esp+3h] [ebp-131h] BYREF
  int v4[5]; // [esp+4h] [ebp-130h] BYREF
  int v5; // [esp+18h] [ebp-11Ch]
  char Buffer[260]; // [esp+1Ch] [ebp-118h] BYREF
  _BYTE *v7; // [esp+124h] [ebp-10h]
  _BYTE *v8; // [esp+128h] [ebp-Ch]
  _BYTE *v9; // [esp+12Ch] [ebp-8h]
  char *v10; // [esp+130h] [ebp-4h]

  memset(a2, 32, 0x80u);
  v7 = a2 + 128;
  v8 = a2;
  v9 = a2 + 256;
  v10 = a2 + 384;
  a2[388] &= ~1u;
  if ( !fgets(Buffer, 127, Stream) )
    return 228;
  if ( Buffer[0] == 42 )
    return 1;
  if ( Buffer[0] == 10 || Buffer[0] == 13 )
    return 229;
  if ( sub_10005FA0((int)Buffer, (int)v4, 6, 0x80u) == 6 )
  {
    sscanf(&Buffer[v5 + 2], "%d", &v3);
    *((_DWORD *)a2 + 96) = v3;
    sub_10006010((int)Buffer, v7, v4[0], v4[1]);
    sub_10006010((int)Buffer, v8, v4[2], v4[3]);
    sub_10006010((int)Buffer, v9, v4[4], v5);
    sub_100061B0(a2);
  }
  return 0;
}

//----- (10006570) --------------------------------------------------------
int __cdecl sub_10006570(FILE *Stream, int a2)
{
  int result; // eax
  int v3; // [esp+4h] [ebp-90h]
  int v4; // [esp+8h] [ebp-8Ch]
  char Buffer[132]; // [esp+Ch] [ebp-88h] BYREF

  HIBYTE(v4) = 0;
  do
  {
LABEL_2:
    if ( HIBYTE(v4) >= 4u )
      return 0;
    if ( !fgets(Buffer, 127, Stream) )
      return 228;
  }
  while ( Buffer[0] == 42 );
  v3 = HIBYTE(v4);
  ++HIBYTE(v4);
  switch ( v3 )
  {
    case 0:
      sscanf(Buffer, "Format Version = %f", a2);
      goto LABEL_2;
    case 1:
      sscanf(Buffer, "Platform = 0x%04X , 0x0x%04X , 0x0x%04X , 0x0x%04X , 0x0x%04X", a2 + 4, v3, v3, v4);
      goto LABEL_2;
    case 2:
      sscanf(Buffer, "Device = 0x%04X", a2 + 8);
      goto LABEL_2;
    case 3:
      sscanf(Buffer, "DeviceVersion = 0x%04X to 0x%04X", a2 + 12, a2 + 16);
      goto LABEL_2;
    default:
      result = 0;
      break;
  }
  return result;
}
// 1000658A: variable 'v4' is possibly undefined

//----- (100066C0) --------------------------------------------------------
int __cdecl sub_100066C0(char *FileName, int a2)
{
  int v3[5]; // [esp+0h] [ebp-1C4h] BYREF
  char v4[384]; // [esp+14h] [ebp-1B0h] BYREF
  int v5; // [esp+194h] [ebp-30h]
  FILE *Stream; // [esp+1ACh] [ebp-18h]
  int v7; // [esp+1B0h] [ebp-14h]
  char *v8; // [esp+1B4h] [ebp-10h]
  int v9; // [esp+1B8h] [ebp-Ch]
  int v10; // [esp+1BCh] [ebp-8h]
  char v11[4]; // [esp+1C0h] [ebp-4h] BYREF

  if ( !a2 )
    return 12;
  Stream = fopen(FileName, "r");
  if ( !Stream )
    return 227;
  v9 = 0;
  v7 = sub_10006570(Stream, (int)v3);
  if ( v7 )
  {
    fclose(Stream);
    return v7;
  }
  else
  {
    sub_10006E10((_BYTE *)(a2 + 8273), v11, 3);
    v8 = v4;
    while ( 1 )
    {
      do
        v7 = sub_100063D0(Stream, v4);
      while ( v7 == 1 );
      if ( v7 )
        break;
      v10 = sub_10005F10(v5);
      sub_10006E10(v8, (_BYTE *)(a2 + v9 + 2), v10);
      v9 += v10;
    }
    *(_DWORD *)(a2 + 8204) = v9;
    fclose(Stream);
    return 0;
  }
}
// 100066C0: using guessed type int var_1C4[5];
// 100066C0: using guessed type char var_4[4];

//----- (100067F0) --------------------------------------------------------
int __cdecl sub_100067F0(_DWORD *a1, int a2)
{
  if ( a1[2] )
  {
    sub_10006E10((_BYTE *)(a2 + *a1 + 2056), (_BYTE *)(a2 + a1[1] + 2), a1[2]);
    *(_DWORD *)(a2 + 6152) += a1[2];
  }
  return 0;
}

//----- (10006850) --------------------------------------------------------
int __cdecl sub_10006850(__int16 a1, int a2)
{
  int i; // [esp+0h] [ebp-330h]
  int v4; // [esp+4h] [ebp-32Ch]
  char v5[268]; // [esp+8h] [ebp-328h] BYREF
  int v6; // [esp+114h] [ebp-21Ch] BYREF
  char v7[264]; // [esp+118h] [ebp-218h] BYREF
  char v8[268]; // [esp+220h] [ebp-110h] BYREF

  sub_10009560(v7, 23, 9, a1, &v6);
  sub_100094B0((int)v8, 4, 0, (int)v7, v6);
  if ( PutPacket(0, 12, v8) != 12 )
    return 2;
  sub_100096F0(v7, 23, 12, 50, &v6);
  sub_100094B0((int)v8, 2, 0, (int)v7, v6);
  if ( PutPacket(0, 10, v8) != 10 )
    return 2;
  if ( !sub_10001AA0(v5, 2000) )
    return 8;
  if ( sub_10001FF0((int)v5) )
    return sub_10002BD0((int)v5);
  if ( v5[1] != 66 )
    return 10;
  v4 = (unsigned __int8)v5[7];
  for ( i = 0; i < v4; ++i )
    *(_BYTE *)(i + a2) = v5[i + 8];
  return 0;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (100069F0) --------------------------------------------------------
int __cdecl sub_100069F0(unsigned __int16 *a1)
{
  int *v1; // eax
  int *v2; // eax
  int v4[6]; // [esp+0h] [ebp-70h] BYREF
  int v5[6]; // [esp+18h] [ebp-58h] BYREF
  char v6[5]; // [esp+33h] [ebp-3Dh]
  unsigned int v7; // [esp+38h] [ebp-38h]
  unsigned __int16 *v8; // [esp+3Ch] [ebp-34h]
  int v9; // [esp+40h] [ebp-30h]
  int v10; // [esp+44h] [ebp-2Ch]
  int v11; // [esp+48h] [ebp-28h]
  int v12; // [esp+4Ch] [ebp-24h]
  int v13; // [esp+50h] [ebp-20h]
  int v14; // [esp+54h] [ebp-1Ch]
  int v15; // [esp+58h] [ebp-18h]
  unsigned int v16; // [esp+5Ch] [ebp-14h]
  int v17; // [esp+60h] [ebp-10h]
  int v18; // [esp+64h] [ebp-Ch]
  int v19; // [esp+68h] [ebp-8h]

  v1 = sub_1000A850(v5, *a1);
  v15 = *v1;
  v16 = v1[1];
  v17 = v1[2];
  v18 = v1[3];
  v19 = v1[4];
  v7 = v16;
  v2 = sub_1000A850(v4, *a1);
  v10 = *v2;
  v11 = v2[1];
  v12 = v2[2];
  v13 = v2[3];
  v14 = v2[4];
  v9 = (unsigned __int16)v10;
  v7 >>= 5;
  v8 = a1 + 1028;
  for ( v6[0] = 0; (unsigned __int8)v6[0] < v7; *(_DWORD *)v6 = (unsigned __int8)(v6[0] + 1) )
  {
    *(_DWORD *)&v6[1] = sub_10006850(v9 + 32 * (unsigned __int8)v6[0], (int)v8);
    if ( *(_DWORD *)&v6[1] )
      return *(_DWORD *)&v6[1];
    v8 += 16;
  }
  return 0;
}
// 100069F0: using guessed type int var_58[6];
// 100069F0: using guessed type int var_70[6];

//----- (10006AE0) --------------------------------------------------------
int __cdecl sub_10006AE0(FILE *Stream, int a2)
{
  int result; // eax
  int v3; // [esp+4h] [ebp-90h]
  unsigned __int8 v4; // [esp+Bh] [ebp-89h]
  char Buffer[132]; // [esp+Ch] [ebp-88h] BYREF

  v4 = 0;
  do
  {
LABEL_2:
    if ( v4 >= 5u )
      return 0;
    if ( !fgets(Buffer, 127, Stream) )
      return 228;
  }
  while ( Buffer[0] == 42 );
  v3 = v4++;
  switch ( v3 )
  {
    case 0:
      sscanf(Buffer, "Format Version = %d.%01d%01d", a2, a2 + 2, a2 + 3);
      if ( *(_WORD *)a2 != 1 || *(_BYTE *)(a2 + 2) || *(_BYTE *)(a2 + 3) )
        v4 += 4;
      goto LABEL_2;
    case 1:
      sscanf(Buffer, "Platform = 0x%04X", a2 + 4);
      goto LABEL_2;
    case 2:
      sscanf(Buffer, "Device = 0x%04X", a2 + 8);
      goto LABEL_2;
    case 3:
      sscanf(Buffer, "Source Device Version = 0x%04X to 0x%04X", a2 + 12, a2 + 16);
      goto LABEL_2;
    case 4:
      sscanf(Buffer, "Destination Device Version = 0x%04X", a2 + 20);
      goto LABEL_2;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (10006C90) --------------------------------------------------------
int __cdecl sub_10006C90(FILE *Stream, int a2)
{
  char Buffer[132]; // [esp+0h] [ebp-88h] BYREF

  if ( !fgets(Buffer, 127, Stream) )
    return 228;
  if ( Buffer[0] == 42 )
    return 1;
  sscanf(Buffer, "Src = 0x%06X, Dest = 0x%06X, Num = 0x%04X", a2, a2 + 4, a2 + 8);
  return 0;
}

//----- (10006D10) --------------------------------------------------------
int __cdecl sub_10006D10(char *FileName, unsigned __int16 *a2)
{
  int v3[6]; // [esp+0h] [ebp-38h] BYREF
  FILE *Stream; // [esp+18h] [ebp-20h]
  char v5; // [esp+1Fh] [ebp-19h]
  int v6; // [esp+20h] [ebp-18h]
  int v7[5]; // [esp+24h] [ebp-14h] BYREF

  v5 = 1;
  if ( !a2 )
    return 12;
  Stream = fopen(FileName, "r");
  if ( !Stream )
    return 227;
  v7[4] = 0;
  v6 = sub_10006AE0(Stream, (int)v3);
  if ( v6 || (v6 = sub_100069F0(a2)) != 0 )
  {
    fclose(Stream);
    return v6;
  }
  else
  {
    while ( 1 )
    {
      do
        v6 = sub_10006C90(Stream, (int)v7);
      while ( v6 == 1 );
      if ( v6 )
        break;
      sub_100067F0(v7, (int)a2);
    }
    fclose(Stream);
    return 0;
  }
}
// 10006D10: using guessed type int var_38[6];

//----- (10006E10) --------------------------------------------------------
_BYTE *__cdecl sub_10006E10(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *result; // eax
  _BYTE *v4; // [esp+8h] [ebp+8h]
  _BYTE *v5; // [esp+Ch] [ebp+Ch]

  result = a1;
  if ( a1 <= a2 )
  {
    v4 = &a1[a3];
    v5 = &a2[a3];
    while ( a3 )
    {
      *--v5 = *--v4;
      result = (_BYTE *)--a3;
    }
  }
  else
  {
    while ( a3 )
    {
      *a2++ = *a1;
      result = ++a1;
      --a3;
    }
  }
  return result;
}

//----- (10006E90) --------------------------------------------------------
int __cdecl sub_10006E90(char a1)
{
  if ( a1 <= 70 && a1 >= 65 )
    return a1 - 55;
  if ( a1 <= 102 && a1 >= 97 )
    return a1 - 87;
  if ( a1 > 57 || a1 < 48 )
    return -1;
  return a1 - 48;
}

//----- (10006EF0) --------------------------------------------------------
int __cdecl sub_10006EF0(char *a1, unsigned __int8 a2)
{
  int result; // eax
  char *v3; // [esp+0h] [ebp-Ch]
  char v4; // [esp+6h] [ebp-6h]
  unsigned __int8 i; // [esp+7h] [ebp-5h]
  char *v6; // [esp+8h] [ebp-4h]

  v3 = a1;
  v6 = &a1[a2 - 1];
  for ( i = 0; ; ++i )
  {
    result = a2 / 2;
    if ( i >= result )
      break;
    v4 = *v3;
    *v3++ = *v6;
    *v6-- = v4;
  }
  return result;
}

//----- (10006F60) --------------------------------------------------------
double __cdecl sub_10006F60(double a1, int a2)
{
  double v4; // [esp+8h] [ebp-10h]
  unsigned int v5; // [esp+14h] [ebp-4h]

  if ( a2 < 0 )
    v5 = -a2;
  else
    v5 = a2;
  v4 = 1.0;
  while ( 1 )
  {
    if ( (v5 & 1) != 0 )
      v4 = v4 * a1;
    v5 >>= 1;
    if ( !v5 )
      break;
    a1 = a1 * a1;
  }
  if ( a2 >= 0 )
    return v4;
  else
    return 1.0 / v4;
}

//----- (10006FD0) --------------------------------------------------------
_DWORD *__thiscall sub_10006FD0(_DWORD *this, void *Src, size_t Size, char a4)
{
  memcpy((char *)this + 13, Src, Size);
  this[2] = Size;
  this[1] = 0;
  *this = 0;
  *((_BYTE *)this + 12) = a4;
  return this;
}

//----- (10007020) --------------------------------------------------------
char __thiscall sub_10007020(int this, char a2, _DWORD *a3)
{
  char v4; // [esp+Bh] [ebp-1h]

  if ( *(_BYTE *)(this + 12) != 1 )
    return a2;
  v4 = *(_BYTE *)(this + (*a3)++ + 13);
  if ( *a3 == *(_DWORD *)(this + 8) )
    *a3 = 0;
  return v4 ^ a2;
}

//----- (10007090) --------------------------------------------------------
char __thiscall sub_10007090(_DWORD *this, char a2)
{
  return sub_10007020((int)this, a2, this);
}

//----- (100070B0) --------------------------------------------------------
_BYTE *__thiscall sub_100070B0(_BYTE *this)
{
  *(_DWORD *)this = 0;
  this[8] = 0;
  *((_DWORD *)this + 1) = 0;
  return this;
}

//----- (100070E0) --------------------------------------------------------
void __thiscall sub_100070E0(void **this)
{
  if ( this[1] )
    operator delete(this[1]);
}
// 1000F060: using guessed type void __cdecl operator delete(void *);

//----- (10007110) --------------------------------------------------------
bool __thiscall sub_10007110(FILE **this)
{
  return feof(*this) != 0;
}

//----- (10007140) --------------------------------------------------------
char __thiscall sub_10007140(FILE **this, char *FileName, char *Mode)
{
  if ( *this )
    return 0;
  if ( !FileName || !*FileName )
    return 0;
  if ( !Mode || !*Mode )
    return 0;
  *this = fopen(FileName, Mode);
  if ( !*this )
    return 0;
  sub_100072C0((size_t)this);
  return 1;
}

//----- (100071B0) --------------------------------------------------------
BOOL __thiscall sub_100071B0(FILE **this)
{
  return fclose(*this) == 0;
}

//----- (100071E0) --------------------------------------------------------
int __thiscall sub_100071E0(int this)
{
  char Buffer; // [esp+7h] [ebp-5h] BYREF
  int v4; // [esp+8h] [ebp-4h]

  if ( fread(&Buffer, 1u, 1u, *(FILE **)this) )
  {
    v4 = Buffer;
    if ( *(_BYTE *)(this + 8) )
      return sub_10007090(*(_DWORD **)(this + 4), v4);
    return v4;
  }
  else
  {
    feof(*(FILE **)this);
    return -1;
  }
}

//----- (10007260) --------------------------------------------------------
int __thiscall sub_10007260(void *this, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  v5 = sub_100071E0((int)this);
  v6 = 0;
  while ( v5 != -1 )
  {
    *(_BYTE *)(v6 + a2) = v5;
    ++v6;
    if ( v5 == 10 || v6 >= a3 )
      break;
    v5 = sub_100071E0((int)this);
  }
  return v6;
}

//----- (100072C0) --------------------------------------------------------
size_t __thiscall sub_100072C0(size_t this)
{
  size_t result; // eax
  int v2; // ecx
  const char *v3; // edi
  char *v4; // esi
  bool v5; // zf
  _DWORD *v6; // [esp+8h] [ebp-11Ch]
  _DWORD *v8; // [esp+10h] [ebp-114h]
  unsigned __int8 v9; // [esp+19h] [ebp-10Bh]
  char v10; // [esp+1Ah] [ebp-10Ah]
  char Buffer[260]; // [esp+1Ch] [ebp-108h] BYREF

  if ( !fread(Buffer, 0xDu, 1u, *(FILE **)this) )
    goto LABEL_2;
  v2 = 3;
  v3 = "TIENCR";
  v4 = Buffer;
  result = 0;
  v5 = 1;
  do
  {
    if ( !v2 )
      break;
    v5 = *(_WORD *)v4 == *(_WORD *)v3;
    v4 += 2;
    v3 += 2;
    --v2;
  }
  while ( v5 );
  if ( !v5 )
  {
LABEL_2:
    *(_BYTE *)(this + 8) = 0;
    return fseek(*(FILE **)this, 0, 0);
  }
  if ( Buffer[6] != 1 )
    goto LABEL_15;
  v10 = Buffer[7];
  result = fread(Buffer, 1u, 1u, *(FILE **)this);
  if ( result )
  {
    v9 = v10 ^ Buffer[0];
    result = fread(Buffer, (unsigned __int8)(v10 ^ Buffer[0]), 1u, *(FILE **)this);
    if ( result )
    {
      sub_100074C0((int)Buffer, v9, 0);
      v8 = operator new(0x110u);
      if ( v8 )
        v6 = sub_10006FD0(v8, Buffer, v9, 1);
      else
        v6 = 0;
      *(_DWORD *)(this + 4) = v6;
      result = this;
      *(_BYTE *)(this + 8) = 1;
LABEL_15:
      if ( !*(_BYTE *)(this + 8) )
        return fseek(*(FILE **)this, 0, 0);
    }
  }
  return result;
}
// 1000F06C: using guessed type void *__cdecl operator new(unsigned int);

//----- (100074C0) --------------------------------------------------------
int __cdecl sub_100074C0(int a1, unsigned __int8 a2, unsigned __int8 a3)
{
  int result; // eax
  int j; // [esp+0h] [ebp-8h]
  int i; // [esp+4h] [ebp-4h]

  result = a3;
  if ( a3 )
  {
    for ( i = 1; i < a2; ++i )
    {
      result = *(char *)(i + a1 - 1);
      *(_BYTE *)(i + a1) ^= result;
    }
  }
  else
  {
    result = a2 - 1;
    for ( j = result; j > 0; --j )
    {
      result = *(char *)(j + a1 - 1) ^ *(char *)(j + a1);
      *(_BYTE *)(j + a1) = result;
    }
  }
  return result;
}

//----- (10007550) --------------------------------------------------------
void __cdecl StartAddress()
{
  int v0; // [esp+0h] [ebp-110h]
  int v1; // [esp+4h] [ebp-10Ch]
  char v2[2]; // [esp+8h] [ebp-108h] BYREF
  unsigned __int8 v3; // [esp+Ah] [ebp-106h]
  unsigned __int8 v4; // [esp+Bh] [ebp-105h]
  char v5; // [esp+Fh] [ebp-101h]
  __int16 v6; // [esp+10h] [ebp-100h]

  while ( !byte_1002BF39 )
  {
    v1 = sub_10001AA0(v2, 2000);
    if ( byte_1002BF39 )
      break;
    if ( v1 > 0 )
    {
      if ( sub_10009420((int)v2) )
      {
        dword_1002BF44 = sub_10003500(v2);
        byte_1002BF39 = 1;
        break;
      }
      v0 = (v4 << 8) + v3;
      if ( v0 )
      {
        if ( v0 == 0x4000 )
        {
          if ( v5 == 2 )
          {
            if ( word_10012510 == v6 )
              ++dword_1002BF4C;
            else
              dword_1002BF44 = 51;
          }
          else
          {
            dword_1002BF44 = 5;
          }
        }
        else if ( (_BYTE)v6 )
        {
          dword_1002BF44 = 52;
          byte_1002BF39 = 1;
        }
        else
        {
          if ( v3 + (v4 << 8) == 2 )
            byte_1002BF39 = 1;
          ++dword_1002BF4C;
        }
      }
      else
      {
        dword_1002BF44 = 10;
        byte_1002BF39 = 1;
      }
    }
  }
  while ( sub_10001AA0(v2, 2000) > 0 )
    ;
  byte_1002BF38 = 0;
}
// 10012510: using guessed type __int16 word_10012510;
// 1002BF38: using guessed type char byte_1002BF38;
// 1002BF39: using guessed type char byte_1002BF39;
// 1002BF44: using guessed type int dword_1002BF44;
// 1002BF4C: using guessed type int dword_1002BF4C;

//----- (100076F0) --------------------------------------------------------
bool __cdecl sub_100076F0(unsigned int a1, unsigned __int8 a2)
{
  __int16 v3; // [esp+Ch] [ebp-114h]
  __int16 v4; // [esp+10h] [ebp-110h] BYREF
  char v5; // [esp+12h] [ebp-10Eh]
  __int16 v6; // [esp+13h] [ebp-10Dh] BYREF
  char v7; // [esp+15h] [ebp-10Bh]
  char v8; // [esp+16h] [ebp-10Ah]
  char v9; // [esp+17h] [ebp-109h]
  char v10; // [esp+18h] [ebp-108h]

  v4 = a2;
  v6 = 4;
  v7 = 0;
  v8 = 0;
  v9 = -125;
  v10 = -34;
  v3 = sub_1000B340((int)&v6, 6);
  v5 = 6;
  if ( !sub_10009930(byte_1001150D, 0, (int)&v4, 9) )
    return 0;
  LOBYTE(v4) = a2;
  HIBYTE(v4) = 100;
  v5 = 2;
  v6 = v3;
  return sub_10009930(byte_1001150D, 0, (int)&v4, 5) && sub_100099A0(a1, 0) != 0;
}
// 1001150D: using guessed type char byte_1001150D;

//----- (10007990) --------------------------------------------------------
bool __cdecl sub_10007990(unsigned int a1, unsigned __int8 a2)
{
  __int16 v3; // [esp+Ch] [ebp-114h]
  __int16 v4; // [esp+10h] [ebp-110h] BYREF
  char v5; // [esp+12h] [ebp-10Eh]
  __int16 v6; // [esp+13h] [ebp-10Dh] BYREF
  char v7; // [esp+15h] [ebp-10Bh]
  char v8; // [esp+16h] [ebp-10Ah]
  char v9; // [esp+17h] [ebp-109h]
  char v10; // [esp+18h] [ebp-108h]

  v4 = a2;
  v6 = 12;
  v7 = 0;
  v8 = 0;
  v9 = -125;
  v10 = -34;
  v3 = sub_1000B340((int)&v6, 6);
  v5 = 6;
  if ( !sub_10009930(byte_1001150D, 0, (int)&v4, 9) )
    return 0;
  LOBYTE(v4) = a2;
  HIBYTE(v4) = 100;
  v5 = 2;
  v6 = v3;
  return sub_10009930(byte_1001150D, 0, (int)&v4, 5) && sub_100099A0(a1, 0) != 0;
}
// 1001150D: using guessed type char byte_1001150D;

//----- (10007C30) --------------------------------------------------------
bool __cdecl sub_10007C30(__int16 a1, unsigned int a2, unsigned __int8 a3)
{
  __int16 v4; // [esp+Ch] [ebp-114h]
  __int16 v5; // [esp+10h] [ebp-110h] BYREF
  char v6; // [esp+12h] [ebp-10Eh]
  _BYTE v7[3]; // [esp+13h] [ebp-10Dh] BYREF
  char v8; // [esp+16h] [ebp-10Ah]

  v5 = a3;
  v7[0] = 11;
  *(_WORD *)&v7[1] = a1;
  v8 = 0;
  v6 = 4;
  if ( !sub_10009930(byte_1001150D, 0, (int)&v5, 7) )
    return 0;
  v4 = sub_1000B340((int)v7, 4);
  LOBYTE(v5) = a3;
  HIBYTE(v5) = 100;
  v6 = 2;
  *(_WORD *)v7 = v4;
  return sub_10009930(byte_1001150D, 0, (int)&v5, 5) && sub_100099A0(a2, 0) != 0;
}
// 1001150D: using guessed type char byte_1001150D;

//----- (10007EB0) --------------------------------------------------------
char __cdecl sub_10007EB0(int a1, int a2, unsigned int a3, __int16 a4)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < a1; ++i )
  {
    if ( !sub_10007C30((a2 + 32 * i) / 32, a3, a4) )
      return 0;
  }
  return 1;
}

//----- (10007F20) --------------------------------------------------------
bool __cdecl sub_10007F20(unsigned int a1, unsigned int a2, __int16 a3)
{
  return sub_100076F0(a1, a3) && sub_10007990(a2, a3);
}

//----- (10007F60) --------------------------------------------------------
char __cdecl sub_10007F60(char a1, char a2, int a3, int a4, __int16 a5)
{
  int v6; // [esp+8h] [ebp-120h]
  int i; // [esp+Ch] [ebp-11Ch]
  int v8; // [esp+10h] [ebp-118h]
  char v9[3]; // [esp+18h] [ebp-110h] BYREF
  char v10[29]; // [esp+1Bh] [ebp-10Dh] BYREF

  v8 = a4 / 29;
  if ( a4 % 29 )
    ++v8;
  v9[0] = a1;
  for ( i = 0; i < v8; ++i )
  {
    v6 = 29;
    if ( i == v8 - 1 )
    {
      if ( a4 % 29 )
        v6 = a4 % 29;
    }
    v9[1] = 29 * i + a2;
    v9[2] = v6;
    qmemcpy(v10, (const void *)(a3 + 29 * i), sizeof(v10));
    if ( !sub_10009930(byte_1001150D, a5, (int)v9, v6 + 3) )
      return 0;
  }
  return 1;
}
// 1001150D: using guessed type char byte_1001150D;

//----- (100080A0) --------------------------------------------------------
char __cdecl sub_100080A0(int a1, int a2, int a3, char a4)
{
  int j; // [esp+10h] [ebp-238h]
  _WORD *v6; // [esp+1Ch] [ebp-22Ch]
  __int16 v7; // [esp+20h] [ebp-228h]
  char v8[264]; // [esp+28h] [ebp-220h] BYREF
  int i; // [esp+130h] [ebp-118h]
  int v10; // [esp+134h] [ebp-114h]
  char v11; // [esp+138h] [ebp-110h] BYREF
  __int16 v12; // [esp+139h] [ebp-10Fh]
  char v13; // [esp+13Bh] [ebp-10Dh]
  _BYTE v14[96]; // [esp+13Ch] [ebp-10Ch] BYREF
  __int16 v15; // [esp+19Ch] [ebp-ACh]
  int v16; // [esp+250h] [ebp+8h]

  if ( a3 != 66 )
    return 0;
  v16 = 2 * a1;
  v10 = 0;
  for ( i = 0; i < 2; ++i )
  {
    v6 = (_WORD *)(a2 + 192 * i / 2);
    v7 = v16 + i + 1;
    dword_10011510[i + v16] = 0;
    for ( j = 0; j < 32; ++j )
      dword_10011510[i + v16] += *(_DWORD *)((_BYTE *)v6 + 3 * j + 2) & 0x3FFFFF;
    ++dword_1002BF3C;
    if ( !sub_10009D20((int)(v6 + 1), 32) )
    {
      *v6 = i + v16;
      v11 = 2;
      v12 = i + v16;
      v13 = 0;
      qmemcpy(v14, v6 + 1, sizeof(v14));
      v15 = sub_1000B340((int)&v11, 100);
      v10 = 102;
      if ( !sub_10007F60(a4, 0, (int)&v11, 102, v7) )
        return 0;
      if ( !sub_100099A0(0x64u, v7) )
        return 0;
    }
    v8[0] = 22;
    v8[1] = 102;
    v8[2] = 1;
    if ( !sub_10009930(byte_1001150C, 1, (int)v8, 3) )
      return 0;
  }
  Sleep(5u);
  return 1;
}
// 1001150C: using guessed type char byte_1001150C;
// 10011510: using guessed type int dword_10011510[1024];
// 1002BF3C: using guessed type int dword_1002BF3C;
// 100080A0: using guessed type char var_220[264];

//----- (10008440) --------------------------------------------------------
char __cdecl sub_10008440(int a1, _BYTE *a2, int a3, unsigned __int16 a4, unsigned __int8 a5)
{
  int i; // [esp+8h] [ebp-124h]
  __int16 v7; // [esp+14h] [ebp-118h]
  __int16 v8; // [esp+18h] [ebp-114h]
  __int16 v9; // [esp+1Ch] [ebp-110h] BYREF
  char v10; // [esp+1Eh] [ebp-10Eh]
  _BYTE v11[3]; // [esp+1Fh] [ebp-10Dh] BYREF
  char v12; // [esp+22h] [ebp-10Ah]
  _BYTE v13[32]; // [esp+23h] [ebp-109h] BYREF
  int v14; // [esp+134h] [ebp+8h]

  if ( a3 != 33 )
    return 0;
  for ( i = 1; i <= 32 && (unsigned __int8)a2[i] == 255; ++i )
  {
    if ( i == 32 )
      return 1;
  }
  v14 = (a4 + 32 * a1) / 32;
  v7 = v14 + 0x4000;
  *a2 = v14;
  v9 = a5;
  v11[0] = 10;
  *(_WORD *)&v11[1] = v14;
  v12 = 0;
  qmemcpy(v13, a2 + 1, sizeof(v13));
  v8 = sub_1000B340((int)v11, 36);
  v10 = 36;
  if ( !sub_10007F60(a5, 0, (int)v11, 36, v14 + 0x4000) )
    return 0;
  LOBYTE(v9) = a5;
  HIBYTE(v9) = 100;
  v10 = 2;
  *(_WORD *)v11 = v8;
  if ( !sub_10009930(byte_1001150D, v7, (int)&v9, 5) )
    return 0;
  if ( !sub_100099A0(0x14u, v7) )
    return 0;
  Sleep(5u);
  return 1;
}
// 1001150D: using guessed type char byte_1001150D;

//----- (10008780) --------------------------------------------------------
int __cdecl sub_10008780(int a1, __int16 a2)
{
  int i; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  while ( 1 )
  {
    if ( byte_1002BF3B )
    {
      FlushTransmitBuffer(0, 1);
      a1 = 34;
      goto LABEL_16;
    }
    v4 = dword_1002BF3C - dword_1002BF4C;
    if ( byte_1002BF39 )
      goto LABEL_16;
    Sleep(0x2EEu);
    for ( i = 0; i < 10; ++i )
    {
      if ( v4 == dword_1002BF3C - dword_1002BF4C )
        Sleep(0x1F4u);
    }
    if ( v4 == dword_1002BF3C - dword_1002BF4C )
      break;
    if ( !v4 || byte_1002BF39 )
      goto LABEL_16;
  }
  if ( v4 )
  {
    byte_1002BF39 = 1;
    if ( dword_1002BF44 )
      a1 = dword_1002BF44;
    else
      a1 = 8;
  }
LABEL_16:
  byte_1002BF39 = 1;
  while ( byte_1002BF38 )
    Sleep(0x14u);
  if ( !dword_1002BF44 )
    return a1;
  sub_100076F0(dword_100110C0, a2);
  return dword_1002BF44;
}
// 1000F0E8: using guessed type _DWORD __cdecl FlushTransmitBuffer(_DWORD, _DWORD);
// 100110C0: using guessed type int dword_100110C0;
// 1002BF38: using guessed type char byte_1002BF38;
// 1002BF39: using guessed type char byte_1002BF39;
// 1002BF3B: using guessed type char byte_1002BF3B;
// 1002BF3C: using guessed type int dword_1002BF3C;
// 1002BF44: using guessed type int dword_1002BF44;
// 1002BF4C: using guessed type int dword_1002BF4C;

//----- (100088B0) --------------------------------------------------------
char sub_100088B0()
{
  __int16 v1; // [esp+8h] [ebp-114h]
  __int16 v2; // [esp+Ch] [ebp-110h] BYREF
  char v3; // [esp+Eh] [ebp-10Eh]
  __int16 v4; // [esp+Fh] [ebp-10Dh] BYREF
  char v5; // [esp+11h] [ebp-10Bh]
  char v6; // [esp+12h] [ebp-10Ah]

  v2 = 22;
  v4 = 8;
  v5 = 0;
  v6 = 0;
  v1 = sub_1000B340((int)&v4, 4);
  v3 = 4;
  if ( !sub_10009930(byte_1001150D, 0, (int)&v2, 7) )
    return 0;
  v2 = 25622;
  v3 = 2;
  v4 = v1;
  if ( !sub_10009930(byte_1001150D, 0, (int)&v2, 5) )
    return 0;
  if ( !sub_100099A0(0x14u, 0) )
    return 0;
  v2 = 1046;
  v3 = 2;
  if ( !sub_10009930(byte_1001150C, 0x4000, (int)&v2, 3) )
    return 0;
  ++dword_1002BF3C;
  return 1;
}
// 1001150C: using guessed type char byte_1001150C;
// 1001150D: using guessed type char byte_1001150D;
// 1002BF3C: using guessed type int dword_1002BF3C;

//----- (10008BA0) --------------------------------------------------------
int __cdecl sub_10008BA0(char *a1, int a2, unsigned __int16 a3, int a4, int a5, int a6, __int16 a7)
{
  char v8[2]; // [esp+8h] [ebp-728h] BYREF
  char v9[192]; // [esp+Ah] [ebp-726h] BYREF
  int v10; // [esp+20Ch] [ebp-524h]
  char v11[2]; // [esp+210h] [ebp-520h] BYREF
  char v12[192]; // [esp+212h] [ebp-51Eh] BYREF
  int k; // [esp+410h] [ebp-320h]
  int j; // [esp+414h] [ebp-31Ch]
  char v15; // [esp+418h] [ebp-318h] BYREF
  char v16[32]; // [esp+419h] [ebp-317h] BYREF
  int i; // [esp+61Ch] [ebp-114h]
  char v18[256]; // [esp+620h] [ebp-110h] BYREF
  HANDLE hThread; // [esp+724h] [ebp-Ch]
  int v20; // [esp+728h] [ebp-8h]
  int v21; // [esp+72Ch] [ebp-4h]
  int v22; // [esp+748h] [ebp+18h]

  dword_1002BF44 = 0;
  dword_1002BF3C = 0;
  dword_1002BF4C = 0;
  byte_1002BF39 = 0;
  dword_1002BF50 = 0;
  while ( sub_10001AA0(v18, 10) > 0 )
    ;
  hThread = (HANDLE)beginthread((_beginthread_proc_type)StartAddress, 0, 0);
  if ( hThread == (HANDLE)-1 )
    return 11;
  SetThreadPriority(hThread, 2);
  byte_1002BF38 = 1;
  v21 = a5 / 32;
  if ( a5 % 32 )
    ++v21;
  v22 = 32 * v21;
  if ( byte_10011030 )
  {
    if ( sub_10007F20(dword_100110C0, dword_100110C4, a7) )
      goto LABEL_14;
    return sub_10008780(2, a7);
  }
  if ( !sub_100076F0(dword_100110C0, a7) || !sub_10007EB0(v21 - a6 / 32, a3, dword_100110C8, a7) )
    return sub_10008780(2, a7);
LABEL_14:
  for ( i = 0; i < v21; ++i )
  {
    qmemcpy(v16, (const void *)(a4 + 32 * i), sizeof(v16));
    if ( !sub_10008440(i, &v15, 33, a3, a7) )
      return sub_10008780(2, a7);
    if ( dword_1002BF44 )
    {
      byte_1002BF39 = 1;
      return sub_10008780(dword_1002BF44, a7);
    }
  }
  v20 = 0;
  for ( j = 0; j < v22 - a6; ++j )
    v20 += *(unsigned __int8 *)(j + a4);
  word_10012510 = v20;
  if ( !sub_100088B0() )
    return sub_10008780(2, a7);
  v21 = a2 / 64;
  if ( a2 % 64 )
    ++v21;
  dword_1002BF50 = 2 * v21 + 1;
  for ( k = 1; k < v21; ++k )
  {
    qmemcpy(v12, &a1[192 * k], sizeof(v12));
    if ( !sub_100080A0(k, (int)v11, 66, 22) )
      return sub_10008780(2, a7);
    if ( dword_1002BF44 )
      return sub_10008780(dword_1002BF44, a7);
    if ( byte_1002BF3B )
    {
      FlushTransmitBuffer(0, 1);
      dword_1002BF44 = 34;
      return sub_10008780(34, a7);
    }
  }
  v10 = 0;
  qmemcpy(v9, a1, sizeof(v9));
  if ( !sub_100080A0(0, (int)v8, 66, 22) )
    return sub_10008780(2, a7);
  if ( dword_1002BF44 || !byte_1002BF3B )
    return sub_10008780(dword_1002BF44, a7);
  FlushTransmitBuffer(0, 1);
  dword_1002BF44 = 34;
  return sub_10008780(34, a7);
}
// 1000F0E8: using guessed type _DWORD __cdecl FlushTransmitBuffer(_DWORD, _DWORD);
// 10011030: using guessed type char byte_10011030;
// 100110C0: using guessed type int dword_100110C0;
// 100110C4: using guessed type int dword_100110C4;
// 100110C8: using guessed type int dword_100110C8;
// 10012510: using guessed type __int16 word_10012510;
// 1002BF38: using guessed type char byte_1002BF38;
// 1002BF39: using guessed type char byte_1002BF39;
// 1002BF3B: using guessed type char byte_1002BF3B;
// 1002BF3C: using guessed type int dword_1002BF3C;
// 1002BF44: using guessed type int dword_1002BF44;
// 1002BF4C: using guessed type int dword_1002BF4C;
// 1002BF50: using guessed type int dword_1002BF50;
// 10008BA0: using guessed type char var_110[256];
// 10008BA0: using guessed type char var_520[2];
// 10008BA0: using guessed type char var_728[2];

//----- (10009030) --------------------------------------------------------
int __cdecl sub_10009030(char *FileName, __int16 a2)
{
  int *v3; // eax
  int *v4; // eax
  int *v5; // eax
  int *v6; // eax
  int v7[6]; // [esp+0h] [ebp-1A0F0h] BYREF
  int v8[6]; // [esp+18h] [ebp-1A0D8h] BYREF
  int v9[6]; // [esp+30h] [ebp-1A0C0h] BYREF
  int v10[7]; // [esp+48h] [ebp-1A0A8h] BYREF
  int k; // [esp+64h] [ebp-1A08Ch]
  int j; // [esp+68h] [ebp-1A088h]
  char v13; // [esp+6Fh] [ebp-1A081h]
  int i; // [esp+70h] [ebp-1A080h]
  unsigned __int16 *v15; // [esp+74h] [ebp-1A07Ch]
  int v16; // [esp+78h] [ebp-1A078h]
  int v17; // [esp+7Ch] [ebp-1A074h]
  unsigned __int16 v18[1026]; // [esp+80h] [ebp-1A070h] BYREF
  int v19; // [esp+884h] [ebp-1986Ch]
  char v20[98304]; // [esp+2090h] [ebp-18060h] BYREF
  unsigned int v21; // [esp+1A090h] [ebp-60h]
  int v22; // [esp+1A098h] [ebp-58h]
  int v23; // [esp+1A09Ch] [ebp-54h]
  int v24; // [esp+1A0A0h] [ebp-50h]
  int v25; // [esp+1A0A4h] [ebp-4Ch]
  int v26; // [esp+1A0A8h] [ebp-48h]
  int v27; // [esp+1A0ACh] [ebp-44h]
  int v28; // [esp+1A0B0h] [ebp-40h]
  int v29; // [esp+1A0B4h] [ebp-3Ch]
  int v30; // [esp+1A0B8h] [ebp-38h]
  int v31; // [esp+1A0BCh] [ebp-34h]
  int v32; // [esp+1A0C0h] [ebp-30h]
  int v33; // [esp+1A0C4h] [ebp-2Ch]
  int v34; // [esp+1A0C8h] [ebp-28h]
  int v35; // [esp+1A0CCh] [ebp-24h]
  int v36; // [esp+1A0D0h] [ebp-20h]
  int v37; // [esp+1A0D4h] [ebp-1Ch]
  int v38; // [esp+1A0D8h] [ebp-18h]
  int v39; // [esp+1A0DCh] [ebp-14h]
  int v40; // [esp+1A0E0h] [ebp-10h]
  int v41; // [esp+1A0E4h] [ebp-Ch]
  int v42; // [esp+1A0E8h] [ebp-8h]

  if ( a2 == 1 )
  {
    byte_1001150D = 14;
    byte_1001150C = 13;
  }
  else
  {
    if ( a2 != 2 )
      return 53;
    byte_1001150D = 30;
    byte_1001150C = 29;
  }
  memset(&v18[1], 255, 0x800u);
  v18[0] = 785;
  v17 = sub_1000D820(FileName, 0, 0, (int)v18);
  if ( v17 )
    return v17;
  v22 = v19;
  v16 = v21 >> 2;
  for ( i = 0; i < v16; ++i )
  {
    v20[3 * i] = v20[4 * i + 3];
    v13 = v20[4 * i + 1];
    v20[3 * i + 1] = v20[4 * i + 2];
    v20[3 * i + 2] = v13 & 0x3F;
  }
  if ( v16 % 64 )
  {
    for ( j = 0; j < 64 - v16 % 64; ++j )
    {
      v20[3 * j + 2 + 3 * v16] = 63;
      v20[3 * j + 1 + 3 * v16] = -1;
      v20[3 * j + 3 * v16] = -1;
    }
  }
  if ( v21 % 4 )
    return 12;
  for ( k = v22; ; ++k )
  {
    v3 = sub_1000A850(v10, v18[0]);
    v38 = *v3;
    v39 = v3[1];
    v40 = v3[2];
    v41 = v3[3];
    v42 = v3[4];
    if ( k >= v39 )
      break;
    *((_BYTE *)&v18[1] + k) = -1;
  }
  sub_1000B230(-1, -1, -1, -1, -1, -1);
  v4 = sub_1000A850(v9, v18[0]);
  v33 = *v4;
  v34 = v4[1];
  v35 = v4[2];
  v36 = v4[3];
  v37 = v4[4];
  v22 = v34;
  v15 = &v18[1];
  v5 = sub_1000A850(v8, v18[0]);
  v28 = *v5;
  v29 = v5[1];
  v30 = v5[2];
  v31 = v5[3];
  v32 = v5[4];
  v6 = sub_1000A850(v7, v18[0]);
  v23 = *v6;
  v24 = v6[1];
  v25 = v6[2];
  v26 = v6[3];
  v27 = v6[4];
  return sub_10008BA0(v20, v16, v23, (int)v15, v22, v30, 22);
}
// 1001150C: using guessed type char byte_1001150C;
// 1001150D: using guessed type char byte_1001150D;
// 10009030: using guessed type unsigned __int16 var_1A070[1026];
// 10009030: using guessed type int var_1A0A8[7];
// 10009030: using guessed type int var_1A0C0[6];
// 10009030: using guessed type int var_1A0D8[6];
// 10009030: using guessed type int var_1A0F0[6];

//----- (100093B0) --------------------------------------------------------
int __cdecl I2CProgram_C816senc(char *FileName)
{
  FILE *Stream; // [esp+0h] [ebp-4h]

  if ( !*FileName )
    return 1465;
  Stream = fopen(FileName, "r");
  if ( !Stream )
    return 221;
  fclose(Stream);
  return sub_10009030(FileName, 2);
}

//----- (10009420) --------------------------------------------------------
bool __cdecl sub_10009420(int a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = *(_BYTE *)(a1 + 1);
  return v2 == 70 || v2 == 77 || v2 == -61;
}

//----- (10009450) --------------------------------------------------------
char __cdecl sub_10009450(int a1)
{
  char result; // al
  unsigned __int8 v2; // [esp+2h] [ebp-2h]
  char v3; // [esp+3h] [ebp-1h]
  unsigned __int8 *v4; // [esp+Ch] [ebp+8h]

  v2 = 0;
  result = a1;
  v3 = *(_BYTE *)(a1 + 5) + 5;
  v4 = (unsigned __int8 *)(a1 + 1);
  while ( v3 )
  {
    v2 = byte_100110D0[v2 ^ *v4++];
    result = --v3;
  }
  *v4 = v2;
  return result;
}

//----- (100094B0) --------------------------------------------------------
char __cdecl sub_100094B0(int a1, char a2, __int16 a3, int a4, int a5)
{
  char result; // al
  int i; // [esp+0h] [ebp-4h]

  result = a5 + 8;
  if ( a5 + 8 <= 263 )
  {
    *(_BYTE *)a1 = -86;
    *(_BYTE *)(a1 + 1) = a2;
    *(_WORD *)(a1 + 2) = a3;
    *(_BYTE *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + 5) = a5;
    for ( i = 0; i < a5; ++i )
      *(_BYTE *)(i + a1 + 6) = *(_BYTE *)(i + a4);
    *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 5) + 7) = 85;
    return sub_10009450(a1);
  }
  return result;
}

//----- (10009560) --------------------------------------------------------
int __cdecl sub_10009560(_BYTE *a1, char a2, char a3, __int16 a4, _DWORD *a5)
{
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  a1[3] = (unsigned __int16)(a4 & 0xFF00) >> 8;
  *a5 = 4;
  return 0;
}

//----- (100095E0) --------------------------------------------------------
int __cdecl sub_100095E0(_BYTE *a1, char a2, char a3, _DWORD *a4)
{
  *a1 = a2;
  a1[1] = a3;
  *a4 = 2;
  return 0;
}

//----- (10009630) --------------------------------------------------------
int __cdecl sub_10009630(_BYTE *a1, char a2, _DWORD *a3)
{
  *a1 = a2;
  *a3 = 1;
  return 0;
}

//----- (10009660) --------------------------------------------------------
int __cdecl sub_10009660(_BYTE *a1, char a2, char a3, unsigned __int8 a4, _BYTE *a5, _DWORD *a6)
{
  unsigned __int8 i; // [esp+3h] [ebp-1h]

  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  for ( i = 3; i < a4 + 3; ++i )
    a1[i] = *a5++;
  *a6 = a4 + 3;
  return 0;
}

//----- (100096F0) --------------------------------------------------------
int __cdecl sub_100096F0(_BYTE *a1, char a2, char a3, int a4, _DWORD *a5)
{
  *a1 = a2;
  a1[1] = a3;
  *a5 = 2;
  return 0;
}

//----- (10009740) --------------------------------------------------------
void __cdecl sub_10009740()
{
  int v0; // [esp+0h] [ebp-110h]
  int v1; // [esp+4h] [ebp-10Ch]
  char v2[2]; // [esp+8h] [ebp-108h] BYREF
  unsigned __int8 v3; // [esp+Ah] [ebp-106h]
  unsigned __int8 v4; // [esp+Bh] [ebp-105h]
  char v5; // [esp+Eh] [ebp-102h]
  _WORD v6[126]; // [esp+Fh] [ebp-101h]

  while ( !byte_1002BF39 )
  {
    v1 = sub_10001AA0(v2, 2000);
    if ( byte_1002BF39 )
      break;
    if ( v1 > 0 )
    {
      if ( sub_10009420((int)v2) )
      {
        dword_1002BF44 = sub_10003500(v2);
        byte_1002BF39 = 1;
        break;
      }
      v0 = (v4 << 8) + v3;
      if ( v0 )
      {
        if ( v0 == 0x4000 )
        {
          if ( LOWORD(dword_10012514[0]) == v6[0] )
            ++dword_1002BF4C;
          else
            dword_1002BF44 = 51;
        }
        else if ( dword_1002BF40 == 32848 )
        {
          if ( v2[1] == 65 && v5 == 26 && !(LOBYTE(v6[1]) | HIBYTE(v6[0]) | LOBYTE(v6[0])) )
          {
LABEL_21:
            if ( v3 + (v4 << 8) == 2 )
              byte_1002BF39 = 1;
            ++dword_1002BF4C;
          }
          else
          {
            dword_1002BF44 = 52;
            byte_1002BF39 = 1;
          }
        }
        else
        {
          if ( dword_10012514[256 * v4 + v3] == *(_DWORD *)((char *)v6 + 1) )
            goto LABEL_21;
          dword_1002BF44 = 52;
          byte_1002BF39 = 1;
        }
      }
      else
      {
        dword_1002BF44 = 10;
        byte_1002BF39 = 1;
      }
    }
  }
  while ( sub_10001AA0(v2, 2000) > 0 )
    ;
  byte_1002BF3A = 0;
}
// 10012514: using guessed type int dword_10012514[];
// 1002BF39: using guessed type char byte_1002BF39;
// 1002BF3A: using guessed type char byte_1002BF3A;
// 1002BF40: using guessed type int dword_1002BF40;
// 1002BF44: using guessed type int dword_1002BF44;
// 1002BF4C: using guessed type int dword_1002BF4C;

//----- (10009930) --------------------------------------------------------
bool __cdecl sub_10009930(char a1, __int16 a2, int a3, int a4)
{
  char v5[260]; // [esp+4h] [ebp-108h] BYREF

  sub_100094B0((int)v5, a1, a2, a3, a4);
  return a4 + 8 == PutPacket(0, a4 + 8, v5);
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);

//----- (100099A0) --------------------------------------------------------
char __cdecl sub_100099A0(unsigned int a1, __int16 a2)
{
  int v3; // [esp+0h] [ebp-114h] BYREF
  char v4[268]; // [esp+4h] [ebp-110h] BYREF

  v3 = 0;
  while ( a1 )
  {
    if ( a1 <= 0xFF )
    {
      sub_10009630(v4, a1, &v3);
      a1 = 0;
    }
    else
    {
      a1 -= 255;
      sub_10009630(v4, 255, &v3);
    }
    if ( !sub_10009930(136, a2, (int)v4, v3) )
      return 0;
  }
  return 1;
}

//----- (10009A60) --------------------------------------------------------
bool __cdecl sub_10009A60(unsigned int a1, char a2)
{
  int v3; // [esp+0h] [ebp-118h] BYREF
  __int16 v4; // [esp+4h] [ebp-114h]
  char v5[268]; // [esp+8h] [ebp-110h] BYREF

  v3 = 0;
  v4 = 0;
  sub_10009560(v5, a2, 7, 33758, &v3);
  return sub_10009930(4, v4, (int)v5, v3) && sub_100099A0(a1, v4) != 0;
}

//----- (10009B10) --------------------------------------------------------
bool __cdecl sub_10009B10(unsigned int a1, char a2)
{
  int v3; // [esp+0h] [ebp-118h] BYREF
  __int16 v4; // [esp+4h] [ebp-114h]
  char v5[268]; // [esp+8h] [ebp-110h] BYREF

  v3 = 0;
  v4 = 0;
  sub_10009560(v5, a2, 18, 33758, &v3);
  return sub_10009930(4, v4, (int)v5, v3) && sub_100099A0(a1, v4) != 0;
}

//----- (10009BC0) --------------------------------------------------------
bool __cdecl sub_10009BC0(__int16 a1, unsigned int a2, char a3)
{
  int v4; // [esp+0h] [ebp-118h] BYREF
  __int16 v5; // [esp+4h] [ebp-114h]
  char v6[268]; // [esp+8h] [ebp-110h] BYREF

  v4 = 0;
  v5 = 0;
  sub_10009560(v6, a3, 17, a1, &v4);
  return sub_10009930(4, v5, (int)v6, v4) && sub_100099A0(a2, v5) != 0;
}

//----- (10009C70) --------------------------------------------------------
char __cdecl sub_10009C70(int a1, int a2, unsigned int a3, __int16 a4)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < a1; ++i )
  {
    if ( !sub_10009BC0((a2 + 32 * i) / 32, a3, a4) )
      return 0;
  }
  return 1;
}

//----- (10009CE0) --------------------------------------------------------
bool __cdecl sub_10009CE0(unsigned int a1, unsigned int a2, __int16 a3)
{
  return sub_10009A60(a1, a3) && sub_10009B10(a2, a3);
}

//----- (10009D20) --------------------------------------------------------
char __cdecl sub_10009D20(int a1, int a2)
{
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    if ( *(unsigned __int8 *)(a1 + 3 * i) != 255
      || *(unsigned __int8 *)(a1 + 3 * i + 1) != 255
      || *(_BYTE *)(a1 + 3 * i + 2) != 63 )
    {
      return 0;
    }
  }
  return 1;
}

//----- (10009D90) --------------------------------------------------------
char __cdecl sub_10009D90(int a1, int a2, int a3, char a4)
{
  char v5[4]; // [esp+0h] [ebp-128h] BYREF
  int j; // [esp+4h] [ebp-124h]
  _BYTE *v7; // [esp+8h] [ebp-120h]
  __int16 v8; // [esp+Ch] [ebp-11Ch]
  int i; // [esp+10h] [ebp-118h]
  int v10; // [esp+14h] [ebp-114h] BYREF
  char v11[268]; // [esp+18h] [ebp-110h] BYREF
  int v12; // [esp+130h] [ebp+8h]

  if ( a3 != 66 )
    return 0;
  v12 = 2 * a1;
  v10 = 0;
  for ( i = 0; i < 2; ++i )
  {
    v7 = (_BYTE *)(a2 + 192 * i / 2);
    v8 = v12 + i + 1;
    dword_10012518[i + v12] = 0;
    for ( j = 0; j < 32; ++j )
      dword_10012518[i + v12] += *(_DWORD *)&v7[3 * j + 2] & 0x3FFFFF;
    ++dword_1002BF48;
    if ( !sub_10009D20((int)(v7 + 2), 32) )
    {
      *(_WORD *)v7 = i + v12;
      sub_10009660(v11, a4, 5, 0x62u, v7, &v10);
      if ( !sub_10009930(5, v8, (int)v11, v10) )
        return 0;
      if ( !sub_100099A0(0x14u, v8) )
        return 0;
    }
    if ( dword_1002BF40 == 32848 )
    {
      sub_100095E0(v11, a4, 26, &v10);
      if ( !sub_10009930(1, v8, (int)v11, v10) )
        return 0;
    }
    else
    {
      v5[0] = i + v12;
      v5[1] = (unsigned __int16)((i + v12) & 0xFF00) >> 8;
      v5[2] = 0;
      sub_10009660(v11, a4, 0, 3u, v5, &v10);
      if ( !sub_10009930(5, v8, (int)v11, v10) )
        return 0;
      sub_100096F0(v11, a4, 3, 4, &v10);
      if ( !sub_10009930(2, v8, (int)v11, v10) )
        return 0;
    }
  }
  Sleep(2u);
  return 1;
}
// 10012518: using guessed type int dword_10012518[1024];
// 1002BF40: using guessed type int dword_1002BF40;
// 1002BF48: using guessed type int dword_1002BF48;

//----- (1000A0B0) --------------------------------------------------------
char __cdecl sub_1000A0B0(int a1, _BYTE *a2, int a3, unsigned __int16 a4, char a5)
{
  int i; // [esp+0h] [ebp-11Ch]
  int v7; // [esp+4h] [ebp-118h] BYREF
  __int16 v8; // [esp+8h] [ebp-114h]
  char v9[268]; // [esp+Ch] [ebp-110h] BYREF
  int v10; // [esp+124h] [ebp+8h]

  if ( a3 != 33 )
    return 0;
  for ( i = 1; i <= 32 && (unsigned __int8)a2[i] == 255; ++i )
  {
    if ( i == 32 )
      return 1;
  }
  v10 = (a4 + 32 * a1) / 32;
  v7 = 0;
  v8 = v10 + 0x4000;
  *a2 = v10;
  sub_10009660(v9, a5, 16, 0x21u, a2, &v7);
  if ( !sub_10009930(5, v8, (int)v9, v7) )
    return 0;
  if ( !sub_100099A0(0x14u, v8) )
    return 0;
  Sleep(5u);
  return 1;
}

//----- (1000A1E0) --------------------------------------------------------
int __cdecl sub_1000A1E0(int a1, __int16 a2)
{
  int i; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  while ( 1 )
  {
    if ( byte_1002BF3B )
    {
      FlushTransmitBuffer(0, 1);
      a1 = 34;
      goto LABEL_15;
    }
    v4 = dword_1002BF48 - dword_1002BF4C;
    if ( byte_1002BF39 )
      goto LABEL_15;
    Sleep(0x2EEu);
    for ( i = 0; i < 10; ++i )
    {
      if ( v4 == dword_1002BF48 - dword_1002BF4C )
        Sleep(0x1F4u);
    }
    if ( v4 == dword_1002BF48 - dword_1002BF4C )
      break;
    if ( !v4 || byte_1002BF39 )
      goto LABEL_15;
  }
  byte_1002BF39 = 1;
  if ( dword_1002BF44 )
    a1 = dword_1002BF44;
  else
    a1 = 8;
LABEL_15:
  byte_1002BF39 = 1;
  while ( byte_1002BF3A )
    Sleep(0x14u);
  if ( !dword_1002BF44 )
    return a1;
  sub_10009A60(dword_10011018, a2);
  return dword_1002BF44;
}
// 1000F0E8: using guessed type _DWORD __cdecl FlushTransmitBuffer(_DWORD, _DWORD);
// 10011018: using guessed type int dword_10011018;
// 1002BF39: using guessed type char byte_1002BF39;
// 1002BF3A: using guessed type char byte_1002BF3A;
// 1002BF3B: using guessed type char byte_1002BF3B;
// 1002BF44: using guessed type int dword_1002BF44;
// 1002BF48: using guessed type int dword_1002BF48;
// 1002BF4C: using guessed type int dword_1002BF4C;

//----- (1000A300) --------------------------------------------------------
char sub_1000A300()
{
  int v1; // [esp+0h] [ebp-114h] BYREF
  char v2[268]; // [esp+4h] [ebp-110h] BYREF

  sub_100095E0(v2, 23, 14, &v1);
  if ( !sub_10009930(1, 0x4000, (int)v2, v1) )
    return 0;
  ++dword_1002BF48;
  return 1;
}
// 1002BF48: using guessed type int dword_1002BF48;

//----- (1000A380) --------------------------------------------------------
int __cdecl ProgramFlash(char *a1, int a2, unsigned __int16 a3, int a4, int a5, int a6, __int16 a7)
{
  return sub_1000A3B0(a1, a2, a3, a4, a5, a6, a7);
}

//----- (1000A3B0) --------------------------------------------------------
int __cdecl sub_1000A3B0(char *a1, int a2, unsigned __int16 a3, int a4, int a5, int a6, __int16 a7)
{
  char v8[2]; // [esp+8h] [ebp-728h] BYREF
  char v9[192]; // [esp+Ah] [ebp-726h] BYREF
  int v10; // [esp+20Ch] [ebp-524h]
  char v11[2]; // [esp+210h] [ebp-520h] BYREF
  char v12[192]; // [esp+212h] [ebp-51Eh] BYREF
  int k; // [esp+410h] [ebp-320h]
  int j; // [esp+414h] [ebp-31Ch]
  char v15; // [esp+418h] [ebp-318h] BYREF
  char v16[32]; // [esp+419h] [ebp-317h] BYREF
  int i; // [esp+61Ch] [ebp-114h]
  char v18[256]; // [esp+620h] [ebp-110h] BYREF
  HANDLE hThread; // [esp+724h] [ebp-Ch]
  int v20; // [esp+728h] [ebp-8h]
  int v21; // [esp+72Ch] [ebp-4h]
  int v22; // [esp+748h] [ebp+18h]

  dword_1002BF44 = 0;
  dword_1002BF48 = 0;
  dword_1002BF4C = 0;
  byte_1002BF39 = 0;
  dword_1002BF50 = 0;
  while ( sub_10001AA0(v18, 10) > 0 )
    ;
  hThread = (HANDLE)beginthread((_beginthread_proc_type)sub_10009740, 0, 0);
  if ( hThread == (HANDLE)-1 )
    return 11;
  SetThreadPriority(hThread, 2);
  byte_1002BF3A = 1;
  v21 = a5 / 32;
  if ( a5 % 32 )
    ++v21;
  v22 = 32 * v21;
  if ( byte_10011030 )
  {
    if ( sub_10009CE0(dword_10011018, dword_1001101C, a7) )
      goto LABEL_14;
    return sub_1000A1E0(2, a7);
  }
  if ( !sub_10009A60(dword_10011018, a7) || !sub_10009C70(v21 - a6 / 32, a3, dword_10011024, a7) )
    return sub_1000A1E0(2, a7);
LABEL_14:
  for ( i = 0; i < v21; ++i )
  {
    qmemcpy(v16, (const void *)(a4 + 32 * i), sizeof(v16));
    if ( !sub_1000A0B0(i, &v15, 33, a3, a7) )
      return sub_1000A1E0(2, a7);
    if ( dword_1002BF44 )
    {
      byte_1002BF39 = 1;
      return sub_1000A1E0(dword_1002BF44, a7);
    }
  }
  v20 = 0;
  for ( j = 0; j < v22 - a6; ++j )
    v20 += *(unsigned __int8 *)(j + a4);
  LOWORD(dword_10012514[0]) = v20;
  if ( !sub_1000A300() )
    return sub_1000A1E0(2, a7);
  v21 = a2 / 64;
  if ( a2 % 64 )
    ++v21;
  dword_1002BF50 = 2 * v21 + 1;
  Sleep(0);
  for ( k = 1; k < v21; ++k )
  {
    qmemcpy(v12, &a1[192 * k], sizeof(v12));
    if ( !sub_10009D90(k, (int)v11, 66, 23) )
      return sub_1000A1E0(2, a7);
    if ( dword_1002BF44 )
      return sub_1000A1E0(dword_1002BF44, a7);
    if ( byte_1002BF3B )
    {
      FlushTransmitBuffer(0, 1);
      dword_1002BF44 = 34;
      return sub_1000A1E0(34, a7);
    }
  }
  v10 = 0;
  qmemcpy(v9, a1, sizeof(v9));
  if ( !sub_10009D90(0, (int)v8, 66, 23) )
    return sub_1000A1E0(2, a7);
  if ( dword_1002BF44 || !byte_1002BF3B )
    return sub_1000A1E0(dword_1002BF44, a7);
  FlushTransmitBuffer(0, 1);
  dword_1002BF44 = 34;
  return sub_1000A1E0(34, a7);
}
// 1000F0E8: using guessed type _DWORD __cdecl FlushTransmitBuffer(_DWORD, _DWORD);
// 10011018: using guessed type int dword_10011018;
// 1001101C: using guessed type int dword_1001101C;
// 10011024: using guessed type int dword_10011024;
// 10011030: using guessed type char byte_10011030;
// 10012514: using guessed type int dword_10012514[];
// 1002BF39: using guessed type char byte_1002BF39;
// 1002BF3A: using guessed type char byte_1002BF3A;
// 1002BF3B: using guessed type char byte_1002BF3B;
// 1002BF44: using guessed type int dword_1002BF44;
// 1002BF48: using guessed type int dword_1002BF48;
// 1002BF4C: using guessed type int dword_1002BF4C;
// 1002BF50: using guessed type int dword_1002BF50;
// 1000A3B0: using guessed type char var_110[256];
// 1000A3B0: using guessed type char var_520[2];
// 1000A3B0: using guessed type char var_728[2];

//----- (1000A850) --------------------------------------------------------
_DWORD *__cdecl sub_1000A850(_DWORD *a1, unsigned __int16 a2)
{
  _DWORD *result; // eax

  if ( a2 > 0x303u )
  {
    if ( a2 > 0x504u )
    {
      if ( a2 >= 0x600u && a2 <= 0x601u )
      {
        *a1 = dword_10011098;
        a1[1] = dword_1001109C;
        a1[2] = dword_100110A0;
        a1[3] = dword_100110A4;
        a1[4] = dword_100110A8;
        return a1;
      }
    }
    else
    {
      if ( a2 >= 0x500u )
      {
        *a1 = dword_10011084;
        a1[1] = dword_10011088;
        a1[2] = dword_1001108C;
        a1[3] = dword_10011090;
        a1[4] = dword_10011094;
        return a1;
      }
      if ( a2 == 785 )
      {
        *a1 = dword_100110AC;
        a1[1] = dword_100110B0;
        a1[2] = dword_100110B4;
        a1[3] = dword_100110B8;
        a1[4] = dword_100110BC;
        return a1;
      }
    }
    goto LABEL_21;
  }
  if ( a2 == 771 || a2 > 0x202u )
  {
LABEL_21:
    *a1 = dword_10011070;
    a1[1] = dword_10011074;
    a1[2] = dword_10011078;
    a1[3] = dword_1001107C;
    a1[4] = dword_10011080;
    return a1;
  }
  if ( a2 == 514 )
  {
    *a1 = dword_1001105C;
    a1[1] = dword_10011060;
    a1[2] = dword_10011064;
    a1[3] = dword_10011068;
    a1[4] = dword_1001106C;
    return a1;
  }
  else
  {
    switch ( a2 )
    {
      case 0x104u:
      case 0x105u:
        *a1 = dword_10011034;
        a1[1] = dword_10011038;
        a1[2] = dword_1001103C;
        a1[3] = dword_10011040;
        a1[4] = dword_10011044;
        result = a1;
        break;
      case 0x200u:
      case 0x201u:
        *a1 = dword_10011048;
        a1[1] = dword_1001104C;
        a1[2] = dword_10011050;
        a1[3] = dword_10011054;
        a1[4] = dword_10011058;
        result = a1;
        break;
      default:
        goto LABEL_21;
    }
  }
  return result;
}
// 10011034: using guessed type int dword_10011034;
// 10011038: using guessed type int dword_10011038;
// 1001103C: using guessed type int dword_1001103C;
// 10011040: using guessed type int dword_10011040;
// 10011044: using guessed type int dword_10011044;
// 10011048: using guessed type int dword_10011048;
// 1001104C: using guessed type int dword_1001104C;
// 10011050: using guessed type int dword_10011050;
// 10011054: using guessed type int dword_10011054;
// 10011058: using guessed type int dword_10011058;
// 1001105C: using guessed type int dword_1001105C;
// 10011060: using guessed type int dword_10011060;
// 10011064: using guessed type int dword_10011064;
// 10011068: using guessed type int dword_10011068;
// 1001106C: using guessed type int dword_1001106C;
// 10011070: using guessed type int dword_10011070;
// 10011074: using guessed type int dword_10011074;
// 10011078: using guessed type int dword_10011078;
// 1001107C: using guessed type int dword_1001107C;
// 10011080: using guessed type int dword_10011080;
// 10011084: using guessed type int dword_10011084;
// 10011088: using guessed type int dword_10011088;
// 1001108C: using guessed type int dword_1001108C;
// 10011090: using guessed type int dword_10011090;
// 10011094: using guessed type int dword_10011094;
// 10011098: using guessed type int dword_10011098;
// 1001109C: using guessed type int dword_1001109C;
// 100110A0: using guessed type int dword_100110A0;
// 100110A4: using guessed type int dword_100110A4;
// 100110A8: using guessed type int dword_100110A8;
// 100110AC: using guessed type int dword_100110AC;
// 100110B0: using guessed type int dword_100110B0;
// 100110B4: using guessed type int dword_100110B4;
// 100110B8: using guessed type int dword_100110B8;
// 100110BC: using guessed type int dword_100110BC;

//----- (1000ABF0) --------------------------------------------------------
int __cdecl ProgSrecFromFile(char *FileName)
{
  return sub_1000AC50(FileName, 0, 0);
}

//----- (1000AC30) --------------------------------------------------------
int __cdecl ProgramSrecWithCfg(char *FileName, char *a2, char *a3)
{
  return sub_1000AC50(FileName, a2, a3);
}

//----- (1000AC50) --------------------------------------------------------
int __cdecl sub_1000AC50(char *FileName, char *a2, char *a3)
{
  int *v4; // eax
  int *v5; // eax
  int *v6; // eax
  int *v7; // eax
  int v8[6]; // [esp+4h] [ebp-1A0F0h] BYREF
  int v9[6]; // [esp+1Ch] [ebp-1A0D8h] BYREF
  int v10[6]; // [esp+34h] [ebp-1A0C0h] BYREF
  int v11[6]; // [esp+4Ch] [ebp-1A0A8h] BYREF
  int k; // [esp+64h] [ebp-1A090h]
  int j; // [esp+68h] [ebp-1A08Ch]
  char v14; // [esp+6Fh] [ebp-1A085h]
  int i; // [esp+70h] [ebp-1A084h]
  unsigned __int16 v16; // [esp+74h] [ebp-1A080h] BYREF
  int v17; // [esp+78h] [ebp-1A07Ch]
  int v18; // [esp+7Ch] [ebp-1A078h]
  __int16 v19; // [esp+80h] [ebp-1A074h]
  unsigned __int16 v20[1026]; // [esp+84h] [ebp-1A070h] BYREF
  int v21; // [esp+888h] [ebp-1986Ch]
  char v22[98304]; // [esp+2094h] [ebp-18060h] BYREF
  unsigned int v23; // [esp+1A094h] [ebp-60h]
  int v24; // [esp+1A09Ch] [ebp-58h]
  int v25; // [esp+1A0A0h] [ebp-54h]
  int v26; // [esp+1A0A4h] [ebp-50h]
  int v27; // [esp+1A0A8h] [ebp-4Ch]
  int v28; // [esp+1A0ACh] [ebp-48h]
  int v29; // [esp+1A0B0h] [ebp-44h]
  int v30; // [esp+1A0B4h] [ebp-40h]
  int v31; // [esp+1A0B8h] [ebp-3Ch]
  int v32; // [esp+1A0BCh] [ebp-38h]
  int v33; // [esp+1A0C0h] [ebp-34h]
  int v34; // [esp+1A0C4h] [ebp-30h]
  int v35; // [esp+1A0C8h] [ebp-2Ch]
  int v36; // [esp+1A0CCh] [ebp-28h]
  int v37; // [esp+1A0D0h] [ebp-24h]
  int v38; // [esp+1A0D4h] [ebp-20h]
  int v39; // [esp+1A0D8h] [ebp-1Ch]
  int v40; // [esp+1A0DCh] [ebp-18h]
  int v41; // [esp+1A0E0h] [ebp-14h]
  int v42; // [esp+1A0E4h] [ebp-10h]
  int v43; // [esp+1A0E8h] [ebp-Ch]
  int v44; // [esp+1A0ECh] [ebp-8h]

  memset(&v20[1], 255, 0x800u);
  v19 = sub_10001D40(13, &v16, 23);
  if ( v19 )
    return v19;
  v20[0] = v16;
  v18 = sub_1000D820(FileName, a2, a3, (int)v20);
  if ( v18 )
    return v18;
  v24 = v21;
  v17 = v23 >> 2;
  for ( i = 0; i < v17; ++i )
  {
    v22[3 * i] = v22[4 * i + 3];
    v14 = v22[4 * i + 1];
    v22[3 * i + 1] = v22[4 * i + 2];
    v22[3 * i + 2] = v14;
  }
  if ( v17 % 64 )
  {
    for ( j = 0; j < 64 - v17 % 64; ++j )
    {
      v22[3 * j + 2 + 3 * v17] = 63;
      v22[3 * j + 1 + 3 * v17] = -1;
      v22[3 * j + 3 * v17] = -1;
    }
  }
  if ( v23 % 4 )
    return 12;
  for ( k = v24; ; ++k )
  {
    v4 = sub_1000A850(v11, v20[0]);
    v40 = *v4;
    v41 = v4[1];
    v42 = v4[2];
    v43 = v4[3];
    v44 = v4[4];
    if ( k >= v41 )
      break;
    *((_BYTE *)&v20[1] + k) = -1;
  }
  sub_1000B230(-1, -1, -1, -1, -1, -1);
  v5 = sub_1000A850(v10, v20[0]);
  v35 = *v5;
  v36 = v5[1];
  v37 = v5[2];
  v38 = v5[3];
  v39 = v5[4];
  v24 = v36;
  if ( v20[0] <= 0x601u && (v20[0] >= 0x600u || v20[0] >= 0x500u && v20[0] <= 0x504u) )
    v19 = sub_1000B310(1, 1);
  v6 = sub_1000A850(v9, v20[0]);
  v30 = *v6;
  v31 = v6[1];
  v32 = v6[2];
  v33 = v6[3];
  v34 = v6[4];
  v7 = sub_1000A850(v8, v20[0]);
  v25 = *v7;
  v26 = v7[1];
  v27 = v7[2];
  v28 = v7[3];
  v29 = v7[4];
  return sub_1000A3B0(v22, v17, v25, (int)&v20[1], v24, v32, 23);
}
// 1000AC50: using guessed type unsigned __int16 var_1A070[1026];
// 1000AC50: using guessed type int var_1A0A8[6];
// 1000AC50: using guessed type int var_1A0C0[6];
// 1000AC50: using guessed type int var_1A0D8[6];
// 1000AC50: using guessed type int var_1A0F0[6];

//----- (1000B010) --------------------------------------------------------
int __cdecl BlastPackets(char *FileName)
{
  int v2; // esi
  int v3; // esi
  FILE *Stream; // [esp+8h] [ebp-114h]
  char Buffer[5]; // [esp+Ch] [ebp-110h] BYREF
  unsigned __int8 v6; // [esp+11h] [ebp-10Bh]
  char v7[261]; // [esp+13h] [ebp-109h] BYREF

  Stream = fopen(FileName, "rb");
  if ( !Stream )
    return 100;
  do
  {
    if ( feof(Stream) )
    {
      fclose(Stream);
      return 0;
    }
    fread(Buffer, 1u, 7u, Stream);
    if ( (unsigned __int8)Buffer[0] != 170 )
    {
LABEL_5:
      fclose(Stream);
      return 100;
    }
    fread(v7, 1u, v6 + 1, Stream);
    switch ( v7[0] )
    {
      case 5:
      case 6:
      case 0x10:
      case 0x11:
        v2 = v6 + 8;
        if ( v2 != PutPacket(0, v2, Buffer) )
          goto LABEL_5;
        break;
      default:
        break;
    }
  }
  while ( (unsigned __int8)Buffer[1] != 136 );
  v3 = v6 + 8;
  if ( v3 != PutPacket(0, v3, Buffer) )
    fclose(Stream);
  return 100;
}
// 1000F104: using guessed type _DWORD __cdecl PutPacket(_DWORD, _DWORD, char *);
// 1000B010: using guessed type char var_109[261];

//----- (1000B1E0) --------------------------------------------------------
int __cdecl ReadFlash(int a1, int a2, void *a3, _DWORD *a4, int *a5, _DWORD *a6, __int16 a7)
{
  return (__int16)sub_1000C670(a1 / 32, *a6 >> 5, *a4 >> 5, a7, a3, a5);
}

//----- (1000B230) --------------------------------------------------------
int __cdecl sub_1000B230(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a1 == -1 )
    dword_10011020 = 200;
  else
    dword_10011020 = 10 * a1;
  if ( a2 == -1 )
    dword_10011018 = 6200;
  else
    dword_10011018 = 10 * a2;
  if ( a3 == -1 )
    dword_10011028 = 20;
  else
    dword_10011028 = 10 * a3;
  if ( a4 == -1 )
    dword_10011024 = 200;
  else
    dword_10011024 = 10 * a4;
  if ( a5 == -1 )
    dword_1001101C = 6200;
  else
    dword_1001101C = 10 * a5;
  if ( a6 == -1 )
    dword_1001102C = 20;
  else
    dword_1001102C = 10 * a6;
  return 0;
}
// 10011018: using guessed type int dword_10011018;
// 1001101C: using guessed type int dword_1001101C;
// 10011020: using guessed type int dword_10011020;
// 10011024: using guessed type int dword_10011024;
// 10011028: using guessed type int dword_10011028;
// 1001102C: using guessed type int dword_1001102C;

//----- (1000B2F0) --------------------------------------------------------
int __cdecl SetOcxCharacteristic(char a1, char a2)
{
  return sub_1000B310(a1, a2);
}

//----- (1000B310) --------------------------------------------------------
int __cdecl sub_1000B310(char a1, char a2)
{
  if ( (a2 & 1) != 0 )
  {
    if ( (a1 & 1) != 0 )
      dword_1002BF40 = 32848;
    else
      dword_1002BF40 = 0;
  }
  return 0;
}
// 1002BF40: using guessed type int dword_1002BF40;

//----- (1000B340) --------------------------------------------------------
__int16 __cdecl sub_1000B340(int a1, int a2)
{
  int i; // [esp+0h] [ebp-8h]
  __int16 v4; // [esp+4h] [ebp-4h]

  v4 = 0;
  for ( i = 0; i < a2; ++i )
    v4 += *(unsigned __int8 *)(i + a1);
  return v4;
}

//----- (1000B390) --------------------------------------------------------
void __cdecl sub_1000B390()
{
  int j; // [esp+8h] [ebp-150h]
  int i; // [esp+10h] [ebp-148h]
  int *v2; // [esp+18h] [ebp-140h]
  int v3; // [esp+1Ch] [ebp-13Ch]
  int v4; // [esp+24h] [ebp-134h]
  int m; // [esp+28h] [ebp-130h]
  unsigned int k; // [esp+34h] [ebp-124h]
  unsigned int v7; // [esp+3Ch] [ebp-11Ch]
  unsigned int v8; // [esp+44h] [ebp-114h]
  unsigned int v9; // [esp+48h] [ebp-110h]
  int v10; // [esp+4Ch] [ebp-10Ch]
  char v11[5]; // [esp+50h] [ebp-108h] BYREF
  char v12; // [esp+55h] [ebp-103h]
  unsigned __int8 v13; // [esp+56h] [ebp-102h]
  unsigned __int8 v14; // [esp+57h] [ebp-101h]
  char v15[252]; // [esp+58h] [ebp-100h] BYREF

  while ( !byte_1002BF58 )
  {
    v10 = sub_10001AA0(v11, 2000);
    if ( byte_1002BF58 )
      break;
    if ( v10 > 0 )
    {
      if ( sub_10009420((int)v11) )
      {
        dword_1002BF54 = sub_10003500(v11);
        byte_1002BF58 = 1;
        break;
      }
      v9 = ((unsigned __int8)v11[3] << 8) + (unsigned __int8)v11[2];
      if ( v9 < 0x1000 || v9 > 0x1040 )
      {
        if ( v9 < 0x1200 || v9 > 0x1500 )
        {
          dword_1002BF54 = 10;
          byte_1002BF58 = 1;
          break;
        }
        if ( word_1002BF5C == 1 || word_1002BF5C == 2 )
        {
          v4 = v14;
          v3 = v13 - 4;
          if ( v12 != 22 && v12 != 4 || v15[v14] || v3 > 96 || v14 > 0x60u || v14 + v3 > 96 )
          {
            dword_1002BF54 = 100;
            byte_1002BF58 = 1;
            break;
          }
          v2 = &off_10011014[32 * v9 - 147456];
          for ( i = 0; i < v4; ++i )
            *((_BYTE *)&v2[(i + v3) / 3] + (i + v3) % 3) = v15[i];
          if ( v3 + v4 == 96 )
            ++dword_1002BF64;
          if ( dword_1002BF64 == dword_1002BF68 )
          {
            byte_1002BF58 = 1;
            break;
          }
        }
        else
        {
          if ( v12 != 99 || v15[96] )
          {
            dword_1002BF54 = 100;
            byte_1002BF58 = 1;
            break;
          }
          for ( j = 0; j < 32; ++j )
            off_10011014[32 * v9 - 147456 + j] = *(_DWORD *)&v15[3 * j] & 0x3FFFFF;
          if ( ++dword_1002BF64 == dword_1002BF68 )
          {
            byte_1002BF58 = 1;
            break;
          }
        }
      }
      else if ( word_1002BF5C == 1 || word_1002BF5C == 2 )
      {
        v8 = v14;
        v7 = v13 - 5;
        if ( v12 != 22 && v12 != 16 || v15[v14] || v7 > 0x20 || v14 > 0x20u || v14 + v7 > 0x20 )
        {
          dword_1002BF54 = 100;
          byte_1002BF58 = 1;
          break;
        }
        for ( k = 0; k < v8; ++k )
          *((_BYTE *)off_10011010 + 32 * v9 + v7 + k - 0x20000) = v15[k];
        if ( dword_1002BF60 != v7 )
        {
          dword_1002BF54 = 5;
          byte_1002BF58 = 1;
          break;
        }
        dword_1002BF60 += v8;
        if ( v7 + v8 == 32 )
        {
          ++dword_1002BF64;
          dword_1002BF60 = 0;
        }
        if ( dword_1002BF64 == dword_1002BF68 )
        {
          byte_1002BF58 = 1;
          break;
        }
      }
      else
      {
        if ( v12 != 35 || v15[32] )
        {
          dword_1002BF54 = 100;
          byte_1002BF58 = 1;
          break;
        }
        for ( m = 0; m < 32; ++m )
          *((_BYTE *)off_10011010 + 32 * v9 + m - 0x20000) = v15[m];
        if ( ++dword_1002BF64 == dword_1002BF68 )
        {
          byte_1002BF58 = 1;
          break;
        }
      }
    }
  }
  while ( sub_10001AA0(v11, 2000) > 0 )
    ;
  byte_1002BF59 = 0;
}
// 10011010: using guessed type void *off_10011010;
// 10011014: using guessed type int *off_10011014;
// 1002BF54: using guessed type int dword_1002BF54;
// 1002BF58: using guessed type char byte_1002BF58;
// 1002BF59: using guessed type char byte_1002BF59;
// 1002BF5C: using guessed type __int16 word_1002BF5C;
// 1002BF60: using guessed type int dword_1002BF60;
// 1002BF64: using guessed type int dword_1002BF64;
// 1002BF68: using guessed type int dword_1002BF68;

//----- (1000B960) --------------------------------------------------------
int sub_1000B960()
{
  int j; // [esp+0h] [ebp-234h]
  __int16 v2; // [esp+10h] [ebp-224h] BYREF
  int v3; // [esp+14h] [ebp-220h]
  int *v4; // [esp+18h] [ebp-21Ch]
  __int16 v5[128]; // [esp+1Ch] [ebp-218h] BYREF
  int i; // [esp+11Ch] [ebp-118h]
  __int16 v7; // [esp+120h] [ebp-114h]
  char v8; // [esp+124h] [ebp-110h] BYREF
  char v9[259]; // [esp+125h] [ebp-10Fh] BYREF
  int v10; // [esp+22Ch] [ebp-8h]
  int v11; // [esp+230h] [ebp-4h] BYREF

  v7 = 0;
  memset(v5, 0, sizeof(v5));
  v8 = 0;
  memset(v9, 0, 0xFFu);
  v10 = 23;
  v2 = 0;
  v11 = 0;
  for ( i = 0; i < 24576; ++i )
    dword_10013518[i] = -1;
  for ( i = 0; i < 768; ++i )
  {
    v5[0] = i;
    LOBYTE(v5[1]) = 0;
    v3 = WriteSMBusBlock(v7, (int)v5, 3, v10);
    if ( v3 )
    {
      Sleep(0x64u);
      v3 = WriteSMBusBlock(v7, (int)v5, 3, v10);
    }
    if ( v3 )
      return v3;
    v2 = 0;
    v3 = ReadSMBusBlock(2, (int)&v8, &v2, v10);
    if ( v3 )
    {
      Sleep(0x64u);
      v2 = 0;
      v3 = ReadSMBusBlock(2, (int)&v8, &v2, v10);
    }
    if ( v3 )
      return v3;
    v4 = &v11;
    if ( v2 != 96 )
      return 5;
    for ( j = 0; j < 32; ++j )
    {
      v4 = &v11;
      LOBYTE(v11) = v9[3 * j - 1];
      v4 = (int *)((char *)&v11 + 1);
      BYTE1(v11) = v9[3 * j];
      v4 = (int *)((char *)&v11 + 2);
      BYTE2(v11) = v9[3 * j + 1];
      v4 = (int *)((char *)&v11 + 3);
      v11 &= 0x3FFFFFu;
      dword_10013518[32 * i + j] = v11;
    }
  }
  return 0;
}
// 10013518: using guessed type int dword_10013518[24576];

//----- (1000BCA0) --------------------------------------------------------
int __cdecl sub_1000BCA0(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  while ( 1 )
  {
    if ( byte_1002BF5A )
    {
      FlushTransmitBuffer(0, 1);
      a1 = 34;
      goto LABEL_10;
    }
    v2 = dword_1002BF68 - dword_1002BF64;
    if ( byte_1002BF58 )
      goto LABEL_10;
    Sleep(0x1676u);
    if ( v2 == dword_1002BF68 - dword_1002BF64 )
      break;
    if ( !v2 || byte_1002BF58 )
      goto LABEL_10;
  }
  byte_1002BF58 = 1;
  if ( dword_1002BF54 )
    a1 = dword_1002BF54;
  else
    a1 = 8;
LABEL_10:
  byte_1002BF58 = 1;
  while ( byte_1002BF59 )
    Sleep(0x14u);
  if ( dword_1002BF54 )
    return dword_1002BF54;
  else
    return a1;
}
// 1000F0E8: using guessed type _DWORD __cdecl FlushTransmitBuffer(_DWORD, _DWORD);
// 1002BF54: using guessed type int dword_1002BF54;
// 1002BF58: using guessed type char byte_1002BF58;
// 1002BF59: using guessed type char byte_1002BF59;
// 1002BF5A: using guessed type char byte_1002BF5A;
// 1002BF64: using guessed type int dword_1002BF64;
// 1002BF68: using guessed type int dword_1002BF68;

//----- (1000BD70) --------------------------------------------------------
bool __cdecl sub_1000BD70(int a1, int a2, __int16 a3, unsigned __int8 a4)
{
  int i; // [esp+0h] [ebp-120h]
  int v6; // [esp+4h] [ebp-11Ch]
  char v7; // [esp+Ah] [ebp-116h]
  __int16 v8; // [esp+Ch] [ebp-114h]
  __int16 v9; // [esp+10h] [ebp-110h] BYREF
  char v10; // [esp+12h] [ebp-10Eh]
  __int16 v11; // [esp+13h] [ebp-10Dh]

  if ( a2 > 16 )
    return 0;
  v7 = 14;
  if ( word_1002BF5C == 2 )
    v7 = 30;
  v9 = a4;
  v10 = a2;
  v6 = 3;
  for ( i = 0; i < a2; ++i )
    *((_BYTE *)&v9 + v6++) = *(_BYTE *)(i + a1);
  v8 = sub_1000B340(a1, a2);
  if ( !sub_10009930(v7, a3, (int)&v9, v6) )
    return 0;
  LOBYTE(v9) = a4;
  HIBYTE(v9) = 100;
  v10 = 2;
  v11 = v8;
  return sub_10009930(v7, a3, (int)&v9, 5);
}
// 1002BF5C: using guessed type __int16 word_1002BF5C;

//----- (1000BF80) --------------------------------------------------------
char __cdecl sub_1000BF80(__int16 a1, __int16 a2, __int16 a3)
{
  int i; // [esp+0h] [ebp-124h]
  char v5; // [esp+Fh] [ebp-115h]
  __int16 v6; // [esp+10h] [ebp-114h]
  char v7; // [esp+14h] [ebp-110h] BYREF
  __int16 v8; // [esp+15h] [ebp-10Fh]
  char v9; // [esp+17h] [ebp-10Dh]
  char v10; // [esp+18h] [ebp-10Ch]

  v6 = a1 + 4096;
  v5 = 13;
  if ( word_1002BF5C == 2 )
    v5 = 29;
  v7 = 7;
  v8 = 32 * (a2 + a1);
  v9 = 0;
  v10 = 32;
  if ( !sub_1000BD70((int)&v7, 5, v6, a3) )
    return 0;
  for ( i = 0; i < 2; ++i )
  {
    v7 = a3;
    LOBYTE(v8) = 19 * i + 5;
    HIBYTE(v8) = 19;
    if ( i == 1 )
      HIBYTE(v8) = 13;
    if ( !sub_10009930(v5, v6, (int)&v7, 3) )
      return 0;
  }
  return 1;
}
// 1000C0D2: conditional instruction was optimized away because ecx.4==1
// 1002BF5C: using guessed type __int16 word_1002BF5C;

//----- (1000C1F0) --------------------------------------------------------
char __cdecl sub_1000C1F0(__int16 a1, __int16 a2, __int16 a3)
{
  int v4; // [esp+0h] [ebp-114h] BYREF
  char v5[268]; // [esp+4h] [ebp-110h] BYREF

  if ( word_1002BF5C )
  {
    if ( word_1002BF5C == 1 || word_1002BF5C == 2 )
      return sub_1000BF80(a1, a2, a3);
    else
      return 0;
  }
  else
  {
    sub_10009560(v5, a3, 9, 32 * (a2 + a1), &v4);
    if ( sub_10009930(4, a1 + 4096, (int)v5, v4) )
    {
      sub_100096F0(v5, a3, 12, 0, &v4);
      return sub_10009930(2, a1 + 4096, (int)v5, v4);
    }
    else
    {
      return 0;
    }
  }
}
// 1002BF5C: using guessed type __int16 word_1002BF5C;

//----- (1000C300) --------------------------------------------------------
char __cdecl sub_1000C300(__int16 a1, __int16 a2)
{
  int i; // [esp+0h] [ebp-124h]
  char v4; // [esp+Fh] [ebp-115h]
  __int16 v5; // [esp+10h] [ebp-114h]
  char v6; // [esp+14h] [ebp-110h] BYREF
  __int16 v7; // [esp+15h] [ebp-10Fh]
  char v8; // [esp+17h] [ebp-10Dh]

  v5 = a1 + 4608;
  v4 = 13;
  if ( word_1002BF5C == 2 )
    v4 = 29;
  v6 = 0;
  v7 = a1;
  v8 = 0;
  if ( !sub_1000BD70((int)&v6, 4, v5, a2) )
    return 0;
  for ( i = 0; i < 6; ++i )
  {
    v6 = a2;
    LOBYTE(v7) = 19 * i + 4;
    HIBYTE(v7) = 19;
    if ( i == 5 )
      HIBYTE(v7) = 1;
    if ( !sub_10009930(v4, v5, (int)&v6, 3) )
      return 0;
  }
  return 1;
}
// 1002BF5C: using guessed type __int16 word_1002BF5C;

//----- (1000C540) --------------------------------------------------------
char __cdecl sub_1000C540(__int16 a1, __int16 a2)
{
  __int16 v3; // [esp+0h] [ebp-118h] BYREF
  char v4; // [esp+2h] [ebp-116h]
  int v5; // [esp+4h] [ebp-114h] BYREF
  char v6[268]; // [esp+8h] [ebp-110h] BYREF

  if ( word_1002BF5C )
  {
    if ( word_1002BF5C == 1 || word_1002BF5C == 2 )
      return sub_1000C300(a1, a2);
    else
      return 0;
  }
  else
  {
    v3 = a1;
    v4 = 0;
    sub_10009660(v6, a2, 0, 3u, &v3, &v5);
    if ( sub_10009930(5, a1 + 4608, (int)v6, v5) )
    {
      sub_100096F0(v6, a2, 2, 0, &v5);
      return sub_10009930(2, a1 + 4608, (int)v6, v5);
    }
    else
    {
      return 0;
    }
  }
}
// 1002BF5C: using guessed type __int16 word_1002BF5C;

//----- (1000C670) --------------------------------------------------------
int __cdecl sub_1000C670(__int16 a1, unsigned int a2, unsigned int a3, unsigned __int8 a4, void *a5, int *a6)
{
  unsigned int j; // [esp+0h] [ebp-110h]
  unsigned int i; // [esp+4h] [ebp-10Ch]
  char v9[256]; // [esp+8h] [ebp-108h] BYREF
  HANDLE hThread; // [esp+10Ch] [ebp-4h]

  off_10011010 = a5;
  off_10011014 = a6;
  word_1002BF5C = 0;
  dword_1002BF54 = 0;
  dword_1002BF64 = 0;
  byte_1002BF58 = 0;
  dword_1002BF68 = a2 + a3;
  while ( sub_10001AA0(v9, 10) > 0 )
    ;
  hThread = (HANDLE)beginthread((_beginthread_proc_type)sub_1000B390, 0, 0);
  if ( hThread == (HANDLE)-1 )
    return 11;
  SetThreadPriority(hThread, 2);
  byte_1002BF59 = 1;
  Sleep(0);
  for ( i = 0; i < a3; ++i )
  {
    if ( !sub_1000C1F0(i, a1, a4) )
      return sub_1000BCA0(2);
    if ( dword_1002BF54 )
    {
      byte_1002BF58 = 1;
      return sub_1000BCA0(dword_1002BF54);
    }
  }
  for ( j = 0; j < a2; ++j )
  {
    if ( !sub_1000C540(j, a4) )
      return sub_1000BCA0(2);
    if ( dword_1002BF54 )
      break;
    if ( byte_1002BF5A )
    {
      FlushTransmitBuffer(0, 1);
      dword_1002BF54 = 34;
      return sub_1000BCA0(34);
    }
  }
  return sub_1000BCA0(dword_1002BF54);
}
// 1000F0E8: using guessed type _DWORD __cdecl FlushTransmitBuffer(_DWORD, _DWORD);
// 10011010: using guessed type void *off_10011010;
// 10011014: using guessed type int *off_10011014;
// 1002BF54: using guessed type int dword_1002BF54;
// 1002BF58: using guessed type char byte_1002BF58;
// 1002BF59: using guessed type char byte_1002BF59;
// 1002BF5A: using guessed type char byte_1002BF5A;
// 1002BF5C: using guessed type __int16 word_1002BF5C;
// 1002BF64: using guessed type int dword_1002BF64;
// 1002BF68: using guessed type int dword_1002BF68;
// 1000C670: using guessed type char var_108[256];

//----- (1000C860) --------------------------------------------------------
int __cdecl CompareSrecWithCfg(char *FileName, char *a2, char *a3)
{
  int *v4; // eax
  int v5[6]; // [esp+0h] [ebp-1A178h] BYREF
  int v6; // [esp+18h] [ebp-1A160h]
  unsigned __int8 *v7; // [esp+1Ch] [ebp-1A15Ch]
  int j; // [esp+20h] [ebp-1A158h]
  int i; // [esp+24h] [ebp-1A154h]
  unsigned __int16 v10; // [esp+28h] [ebp-1A150h] BYREF
  __int16 v11; // [esp+2Ch] [ebp-1A14Ch]
  char v12[260]; // [esp+30h] [ebp-1A148h] BYREF
  int v13; // [esp+134h] [ebp-1A044h]
  int v14; // [esp+138h] [ebp-1A040h]
  int v15; // [esp+13Ch] [ebp-1A03Ch]
  unsigned __int16 v16[1026]; // [esp+140h] [ebp-1A038h] BYREF
  int v17; // [esp+944h] [ebp-19834h]
  _DWORD v18[24576]; // [esp+2150h] [ebp-18028h] BYREF
  unsigned int v19; // [esp+1A150h] [ebp-28h]
  int v20; // [esp+1A158h] [ebp-20h]
  int v21; // [esp+1A15Ch] [ebp-1Ch]
  int v22; // [esp+1A160h] [ebp-18h]
  int v23; // [esp+1A164h] [ebp-14h]
  int v24; // [esp+1A168h] [ebp-10h]
  int v25; // [esp+1A16Ch] [ebp-Ch]
  int v26; // [esp+1A170h] [ebp-8h]

  while ( sub_10001AA0(v12, 2000) > 0 )
    ;
  v11 = sub_10001D40(13, &v10, 23);
  if ( v11 )
    return v11;
  v16[0] = v10;
  v15 = sub_1000D820(FileName, a2, a3, (int)v16);
  if ( v15 )
    return v15;
  v20 = v17;
  v13 = v19 >> 2;
  if ( v19 % 4 )
    return 225;
  v4 = sub_1000A850(v5, v16[0]);
  v22 = *v4;
  v23 = v4[1];
  v24 = v4[2];
  v25 = v4[3];
  v26 = v4[4];
  v21 = (unsigned __int16)v22 / 32;
  v14 = sub_1000C670(v21, (v13 % 32 != 0) + v13 / 32, (v20 % 32 != 0) + v20 / 32, 0x17u, &unk_1002B518, &dword_10013518);
  if ( v14 )
    return v14;
  for ( i = 0; i < v20; ++i )
  {
    if ( *((unsigned __int8 *)off_10011010 + i) != *((unsigned __int8 *)&v16[1] + i) )
      return 11;
  }
  for ( j = 0; j < v13; ++j )
  {
    v7 = (unsigned __int8 *)&v18[j] + 1;
    v6 = HIBYTE(v18[j]) + (BYTE2(v18[j]) << 8) + (*v7 << 16);
    if ( v6 != off_10011014[j] )
      return 11;
  }
  return 0;
}
// 10011010: using guessed type void *off_10011010;
// 10011014: using guessed type int *off_10011014;
// 10013518: using guessed type int dword_10013518;
// 1000C860: using guessed type char var_1A148[260];
// 1000C860: using guessed type unsigned __int16 var_1A038[1026];
// 1000C860: using guessed type int var_1A178[6];

//----- (1000CB00) --------------------------------------------------------
int __cdecl ReadC816Senc(char *FileName, __int16 a2)
{
  int v3; // [esp+4h] [ebp-174h] BYREF
  int m; // [esp+8h] [ebp-170h]
  char v5; // [esp+Fh] [ebp-169h] BYREF
  int k; // [esp+10h] [ebp-168h]
  int j; // [esp+14h] [ebp-164h]
  __int16 v8; // [esp+18h] [ebp-160h]
  unsigned int i; // [esp+1Ch] [ebp-15Ch]
  char v10[256]; // [esp+20h] [ebp-158h] BYREF
  int v11; // [esp+120h] [ebp-58h]
  int v12; // [esp+124h] [ebp-54h]
  HANDLE hThread; // [esp+128h] [ebp-50h]
  int v14; // [esp+12Ch] [ebp-4Ch]
  int v15; // [esp+130h] [ebp-48h]
  int Buffer[3]; // [esp+134h] [ebp-44h] BYREF
  char v17; // [esp+140h] [ebp-38h]
  int v18; // [esp+141h] [ebp-37h]
  int v19; // [esp+145h] [ebp-33h]
  int v20; // [esp+149h] [ebp-2Fh]
  int v21; // [esp+14Dh] [ebp-2Bh]
  __int16 v22; // [esp+158h] [ebp-20h]
  int v23; // [esp+15Ch] [ebp-1Ch]
  int v24; // [esp+160h] [ebp-18h]
  int v25; // [esp+164h] [ebp-14h] BYREF
  int v26; // [esp+168h] [ebp-10h]
  FILE *Stream; // [esp+16Ch] [ebp-Ch]
  unsigned int v28; // [esp+170h] [ebp-8h]
  int v29; // [esp+174h] [ebp-4h]

  off_10011010 = &unk_1002B518;
  off_10011014 = dword_10013518;
  v22 = 0;
  dword_1002BF54 = 0;
  dword_1002BF64 = 0;
  byte_1002BF58 = 0;
  word_1002BF5C = a2;
  v28 = 32;
  v23 = 768;
  v29 = 512;
  v26 = 22;
  if ( a2 )
  {
    if ( a2 != 2 )
      return 1411;
    v28 = 32;
    v23 = 512;
    v29 = 512;
    v24 = 0x4000;
    v11 = 1024;
    v15 = 0x100000;
    v12 = 0x4000;
    word_1002BF5C = 2;
    v26 = 22;
    dword_1002BF68 = 544;
  }
  else
  {
    v28 = 62;
    v23 = 768;
    v29 = 512;
    v24 = 0x4000;
    v11 = 1984;
    v15 = 0x100000;
    v12 = 24576;
    word_1002BF5C = 0;
    v26 = 23;
    dword_1002BF68 = 62;
  }
  while ( sub_10001AA0(v10, 10) > 0 )
    ;
  hThread = (HANDLE)beginthread((_beginthread_proc_type)sub_1000B390, 0, 0);
  if ( hThread == (HANDLE)-1 )
    return 11;
  SetThreadPriority(hThread, 2);
  byte_1002BF59 = 1;
  Sleep(0);
  for ( i = 0; i < v28; ++i )
  {
    if ( !sub_1000C1F0(i, v29, (unsigned __int8)v26) )
      return sub_1000BCA0(2);
    if ( dword_1002BF54 )
    {
      byte_1002BF58 = 1;
      return sub_1000BCA0(dword_1002BF54);
    }
  }
  if ( a2 )
  {
    for ( j = 0; j < v23; ++j )
    {
      if ( !sub_1000C540(j, (unsigned __int8)v26) )
        return sub_1000BCA0(2);
      if ( dword_1002BF54 )
        return sub_1000BCA0(dword_1002BF54);
      if ( byte_1002BF5A )
      {
        FlushTransmitBuffer(0, 1);
        dword_1002BF54 = 34;
        return sub_1000BCA0(34);
      }
    }
    v8 = sub_1000BCA0(dword_1002BF54);
    if ( v8 )
      return v8;
  }
  else
  {
    sub_1000BCA0(dword_1002BF54);
    byte_1002BF59 = 0;
    v14 = CheckForError();
    v14 = sub_1000B960();
    if ( v14 )
      return v14;
  }
  Stream = fopen(FileName, "wb");
  if ( !Stream )
    return 221;
  Buffer[2] = 0;
  v17 = 0;
  Buffer[0] = 1313163604;
  Buffer[1] = 152131;
  v18 = v24;
  v19 = v11;
  v20 = v15;
  v21 = v12;
  if ( fwrite(Buffer, 0x1Du, 1u, Stream) == 1 )
  {
    v25 = 0;
    for ( k = 0; k < v11; ++k )
    {
      v5 = k ^ *((_BYTE *)off_10011010 + k);
      if ( fwrite(&v5, 1u, 1u, Stream) != 1 )
        goto LABEL_37;
      v25 += *((unsigned __int8 *)off_10011010 + k);
      if ( k % 16 == 15 )
      {
        v25 = ~v25;
        if ( fwrite(&v25, 4u, 1u, Stream) != 1 )
        {
LABEL_37:
          fclose(Stream);
          return 221;
        }
        v25 = 0;
      }
    }
    for ( m = 0; m < v12; ++m )
    {
      v3 = m ^ off_10011014[m];
      if ( fwrite(&v3, 4u, 1u, Stream) != 1 )
        goto LABEL_45;
      v25 += off_10011014[m];
      if ( m % 16 == 15 )
      {
        v25 = ~v25;
        if ( fwrite(&v25, 4u, 1u, Stream) != 1 )
        {
LABEL_45:
          fclose(Stream);
          return 221;
        }
        v25 = 0;
      }
    }
    fclose(Stream);
    return 0;
  }
  else
  {
    fclose(Stream);
    return 221;
  }
}
// 1000F0E8: using guessed type _DWORD __cdecl FlushTransmitBuffer(_DWORD, _DWORD);
// 10011010: using guessed type void *off_10011010;
// 10011014: using guessed type int *off_10011014;
// 10013518: using guessed type int dword_10013518[24576];
// 1002BF54: using guessed type int dword_1002BF54;
// 1002BF58: using guessed type char byte_1002BF58;
// 1002BF59: using guessed type char byte_1002BF59;
// 1002BF5A: using guessed type char byte_1002BF5A;
// 1002BF5C: using guessed type __int16 word_1002BF5C;
// 1002BF64: using guessed type int dword_1002BF64;
// 1002BF68: using guessed type int dword_1002BF68;
// 1000CB00: using guessed type char var_158[256];

//----- (1000D0E0) --------------------------------------------------------
int __cdecl sub_1000D0E0(char *a1)
{
  unsigned int v2; // [esp+0h] [ebp-4h]
  unsigned int v3; // [esp+0h] [ebp-4h]

  v2 = sub_10006E90(*a1);
  if ( v2 >= 0x100 )
    return -1;
  v3 = 16 * v2 + sub_10006E90(a1[1]);
  if ( v3 < 0x100 )
    return v3;
  else
    return -1;
}

//----- (1000D140) --------------------------------------------------------
int __cdecl sub_1000D140(char **a1)
{
  unsigned int v2; // [esp+0h] [ebp-4h]

  *a1 += 2;
  v2 = sub_1000D0E0(*a1);
  if ( v2 < 0x100 )
    return v2;
  else
    return -1;
}

//----- (1000D180) --------------------------------------------------------
int __cdecl sub_1000D180(int a1)
{
  return (unsigned __int8)sub_1000D0E0((char *)(a1 + 2));
}

//----- (1000D1B0) --------------------------------------------------------
int __cdecl sub_1000D1B0(int a1)
{
  unsigned int v2; // [esp+0h] [ebp-4h]

  v2 = sub_1000D180(a1) - 3;
  if ( v2 >= 0x100 )
    return -1;
  switch ( *(_BYTE *)(a1 + 1) )
  {
    case '1':
      return v2;
    case '2':
      return v2 - 1;
    case '3':
      return v2 - 2;
  }
  return -2;
}

//----- (1000D220) --------------------------------------------------------
int __cdecl sub_1000D220(char *a1, _BYTE *a2)
{
  unsigned __int8 i; // [esp+1h] [ebp-7h]
  unsigned __int8 v4; // [esp+2h] [ebp-6h]
  char *v5; // [esp+4h] [ebp-4h] BYREF

  v5 = a1;
  v4 = sub_1000D180((int)a1);
  *a2 = 0;
  for ( i = 0; i < (int)v4; ++i )
    *a2 += sub_1000D140(&v5);
  *a2 = ~*a2;
  if ( (unsigned __int8)sub_1000D140(&v5) == (unsigned __int8)*a2 )
    return 0;
  else
    return 224;
}

//----- (1000D2B0) --------------------------------------------------------
int __cdecl sub_1000D2B0(char *a1, int *a2)
{
  char v3; // [esp+3h] [ebp-Dh] BYREF
  char *v4; // [esp+4h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-8h]
  char *v6; // [esp+Ch] [ebp-4h] BYREF

  if ( sub_1000D220(a1, &v3) )
    return 224;
  v5 = sub_1000D0E0(a1 + 2);
  v4 = a1;
  v6 = a1 + 4;
  *a2 = sub_1000D0E0(a1 + 4);
  *a2 <<= 8;
  *a2 += sub_1000D140(&v6);
  return 0;
}

//----- (1000D330) --------------------------------------------------------
int __cdecl sub_1000D330(char *a1, _BYTE *a2, int *a3)
{
  char v4; // al
  char v5; // al
  char v6; // [esp+7h] [ebp-15h] BYREF
  char *v7; // [esp+8h] [ebp-14h]
  char *v8; // [esp+Ch] [ebp-10h]
  char i; // [esp+12h] [ebp-Ah]
  char v10; // [esp+13h] [ebp-9h]
  char *v11; // [esp+14h] [ebp-8h] BYREF
  _BYTE *v12; // [esp+18h] [ebp-4h]

  v12 = a2;
  v8 = a1;
  v7 = a1;
  v11 = a1 + 4;
  if ( sub_1000D220(a1, &v6) )
    return 224;
  v10 = sub_1000D1B0((int)a1);
  *a3 = sub_1000D0E0(v11);
  *a3 <<= 8;
  *a3 += sub_1000D140(&v11);
  if ( a1[1] <= 49 )
  {
    v11 = v8 + 8;
  }
  else
  {
    *a3 <<= 8;
    *a3 += sub_1000D140(&v11);
    if ( a1[1] <= 50 )
    {
      v11 = v7 + 10;
    }
    else
    {
      *a3 <<= 8;
      *a3 += sub_1000D140(&v11);
      v11 = a1 + 12;
    }
  }
  if ( !v10 )
    return 0;
  v4 = sub_1000D0E0(v11);
  *v12++ = v4;
  for ( i = v10 - 1; i; --i )
  {
    v5 = sub_1000D140(&v11);
    *v12++ = v5;
  }
  return 0;
}

//----- (1000D4A0) --------------------------------------------------------
int __cdecl sub_1000D4A0(FILE *Stream, int a2)
{
  int j; // [esp+0h] [ebp-A0h]
  int i; // [esp+4h] [ebp-9Ch]
  int Buffer; // [esp+8h] [ebp-98h] BYREF
  char v6; // [esp+Eh] [ebp-92h]
  char v7; // [esp+Fh] [ebp-91h]
  char v8[4]; // [esp+88h] [ebp-18h] BYREF
  int v9; // [esp+8Ch] [ebp-14h]
  int v10; // [esp+94h] [ebp-Ch]
  int v11; // [esp+9Ch] [ebp-4h]

  if ( !fread(&Buffer, 0xDu, 1u, Stream) )
    return 222;
  if ( strncmp("TIENCR", (const char *)&Buffer, 6u) )
    return 223;
  if ( v6 != 2 && v7 )
    return 223;
  if ( !fread(v8, 0x10u, 1u, Stream) )
    return 225;
  *(_DWORD *)(a2 + 2052) = v9;
  *(_DWORD *)(a2 + 106512) = 4 * v10;
  v11 = 0;
  for ( i = 0; i < v9; ++i )
  {
    if ( i && !(i % 16) )
    {
      if ( !fread(&Buffer, 4u, 1u, Stream) )
        return 225;
      if ( ~v11 != Buffer )
        return 224;
      v11 = 0;
    }
    if ( !fread(&Buffer, 1u, 1u, Stream) )
      return 225;
    *(_BYTE *)(i + a2 + 2) = i ^ Buffer;
    v11 += *(unsigned __int8 *)(i + a2 + 2);
  }
  if ( !fread(&Buffer, 4u, 1u, Stream) )
    return 225;
  if ( ~v11 != Buffer )
    return 224;
  v11 = 0;
  for ( j = 0; j < v10; ++j )
  {
    if ( j && !(j % 16) )
    {
      if ( !fread(&Buffer, 4u, 1u, Stream) )
        return 225;
      if ( ~v11 != Buffer )
        return 224;
      v11 = 0;
    }
    if ( !fread(&Buffer, 4u, 1u, Stream) )
      return 225;
    v11 += j ^ Buffer;
    Buffer ^= j;
    *(_BYTE *)(a2 + 4 * j + 8208) = HIBYTE(Buffer);
    *(_BYTE *)(a2 + 4 * j + 8209) = BYTE2(Buffer);
    *(_BYTE *)(a2 + 4 * j + 8210) = BYTE1(Buffer);
    *(_BYTE *)(a2 + 4 * j + 8211) = Buffer;
  }
  if ( !fread(&Buffer, 4u, 1u, Stream) )
    return 225;
  if ( ~v11 == Buffer )
    return 0;
  return 224;
}
// 1000D4A0: using guessed type char var_18[4];

//----- (1000D820) --------------------------------------------------------
int __cdecl sub_1000D820(char *FileName, char *a2, char *a3, int a4)
{
  int v5; // [esp+Ch] [ebp-390h]
  int v6; // [esp+18h] [ebp-384h]
  int v7; // [esp+30h] [ebp-36Ch]
  int v8; // [esp+34h] [ebp-368h]
  char v9[260]; // [esp+38h] [ebp-364h] BYREF
  int v10; // [esp+13Ch] [ebp-260h]
  char v11[260]; // [esp+140h] [ebp-25Ch] BYREF
  void *v12[3]; // [esp+244h] [ebp-158h] BYREF
  int v13; // [esp+250h] [ebp-14Ch]
  int v14; // [esp+254h] [ebp-148h]
  char v15; // [esp+25Bh] [ebp-141h]
  int v16[2]; // [esp+25Ch] [ebp-140h] BYREF
  char v17; // [esp+267h] [ebp-135h]
  int v18; // [esp+268h] [ebp-134h]
  int v19; // [esp+26Ch] [ebp-130h]
  char v20; // [esp+273h] [ebp-129h]
  int v21; // [esp+274h] [ebp-128h]
  char v22[260]; // [esp+278h] [ebp-124h] BYREF
  FILE *Stream; // [esp+380h] [ebp-1Ch]
  unsigned int v24; // [esp+384h] [ebp-18h] BYREF
  char *v25; // [esp+388h] [ebp-14h]
  char v26; // [esp+38Eh] [ebp-Eh]
  char v27; // [esp+38Fh] [ebp-Dh]
  int v28; // [esp+398h] [ebp-4h]

  sub_100070B0(v12);
  v28 = 0;
  *(_DWORD *)(a4 + 2052) = 0;
  *(_DWORD *)(a4 + 106512) = 0;
  *(_DWORD *)(a4 + 8204) = 0;
  *(_DWORD *)(a4 + 6152) = 0;
  v17 = 0;
  v27 = 0;
  v15 = 0;
  v20 = 0;
  v19 = 0;
  v16[0] = 0;
  v26 = 0;
  v25 = v22;
  if ( !a4 )
  {
    v28 = -1;
    sub_100070E0(v12);
    return 12;
  }
  if ( !FileName )
    goto LABEL_7;
  if ( !*FileName )
    goto LABEL_7;
  Stream = fopen(FileName, "rb");
  if ( !Stream )
    goto LABEL_7;
  v13 = sub_1000D4A0(Stream, a4);
  fclose(Stream);
  if ( v13 == 223 )
  {
    if ( !sub_10007140((FILE **)v12, FileName, "rb") )
    {
LABEL_7:
      v28 = -1;
      sub_100070E0(v12);
      return 221;
    }
    memset((void *)(a4 + 2), 255, 0x800u);
    v21 = 98304;
    memset((void *)(a4 + 8208), 255, 0x18000u);
    v10 = a4 + 8208 + v21;
    v21 = 0;
    v18 = 0;
LABEL_11:
    while ( !sub_10007110((FILE **)v12) )
    {
      v16[1] = (int)v22;
      if ( sub_10007260(v12, (int)v22, 256) <= 0 )
        break;
      if ( *v25 != 83 )
      {
        v13 = 222;
        break;
      }
      v13 = 0;
      switch ( v25[1] )
      {
        case '0':
          v27 = 1;
          v14 = sub_1000D180((int)v22);
          sub_10006E10(v22, v11, 2 * v14 + 4);
          goto LABEL_11;
        case '1':
        case '2':
        case '3':
          v17 = 1;
          break;
        case '5':
          if ( !v20 )
            v20 = 1;
          break;
        case '7':
        case '8':
        case '9':
          v15 = 1;
          break;
        default:
          v13 = 223;
          break;
      }
      if ( v13 )
        break;
      if ( v17 )
      {
        ++v19;
        v14 = sub_1000D1B0((int)v22);
        if ( v14 )
        {
          if ( sub_1000D330(v22, v9, (int *)&v24) )
          {
            v13 = 224;
            break;
          }
          if ( v24 < 0x100000 )
          {
            if ( v24 >= 0xB200 || v24 <= 0xAFFF )
            {
              if ( v24 >= 0x4400 || v24 <= 0x3FFF )
              {
                if ( v24 < 0x4800 && v24 > 0x3FFF )
                {
                  v24 %= 0x800u;
                  if ( v24 + v14 <= 0x800 )
                  {
                    sub_10006E10(v9, (_BYTE *)(a4 + v24 + 2), v14);
                    if ( *(_DWORD *)(a4 + 2052) < v14 + v24 )
                      *(_DWORD *)(a4 + 2052) = v14 + v24;
                  }
                }
              }
              else
              {
                v24 %= 0x400u;
                if ( v24 + v14 <= 0x400 )
                {
                  sub_10006E10(v9, (_BYTE *)(a4 + v24 + 2), v14);
                  if ( *(_DWORD *)(a4 + 2052) < v14 + v24 )
                    *(_DWORD *)(a4 + 2052) = v14 + v24;
                }
              }
            }
            else
            {
              v24 %= 0x200u;
              if ( v24 + v14 <= 0x200 )
              {
                sub_10006E10(v9, (_BYTE *)(a4 + v24 + 2), v14);
                if ( *(_DWORD *)(a4 + 2052) < v14 + v24 )
                  *(_DWORD *)(a4 + 2052) = v14 + v24;
              }
            }
          }
          else
          {
            v24 -= 0x100000;
            if ( v24 + v14 <= 0x18000 )
            {
              sub_10006E10(v9, (_BYTE *)(a4 + v24 + 8208), v14);
              *(_DWORD *)(a4 + 106512) += v14;
            }
          }
          v17 = 0;
        }
      }
      else if ( v20 == 1 )
      {
        if ( sub_1000D2B0(v22, v16) )
        {
          v13 = 224;
          break;
        }
        ++v20;
      }
      else if ( v15 )
      {
        if ( v20 == 2 && v16[0] != v19 )
        {
          v28 = -1;
          sub_100070E0(v12);
          return 225;
        }
        v15 = 0;
        break;
      }
    }
    sub_100071B0((FILE **)v12);
  }
  if ( v13 )
  {
    v6 = v13;
    v28 = -1;
    sub_100070E0(v12);
    return v6;
  }
  else if ( a2 && *a2 && (v8 = sub_100066C0(a2, a4)) != 0 )
  {
    v28 = -1;
    sub_100070E0(v12);
    return v8;
  }
  else if ( a3 && *a3 && (v7 = sub_10006D10(a3, (unsigned __int16 *)a4)) != 0 )
  {
    v28 = -1;
    sub_100070E0(v12);
    return v7;
  }
  else if ( v13 )
  {
    v5 = v13;
    v28 = -1;
    sub_100070E0(v12);
    return v5;
  }
  else
  {
    v28 = -1;
    sub_100070E0(v12);
    return 0;
  }
}
// 1000DE0A: conditional instruction was optimized away because %var_18.4<4000u
// 1000D820: using guessed type char var_25C[260];

//----- (1000E534) --------------------------------------------------------
int sub_1000E534()
{
  return _clean_type_info_names_internal(&unk_100114FC);
}
// 1000E900: using guessed type int __cdecl _clean_type_info_names_internal(_DWORD);

//----- (1000E5F8) --------------------------------------------------------
void *sub_1000E5F8()
{
  return &unk_1000FA70;
}

//----- (1000EA2B) --------------------------------------------------------
int sub_1000EA2B()
{
  dword_1002FF70 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 1002FF70: using guessed type int dword_1002FF70;

// nfuncs=222 queued=189 decompiled=189 lumina nreq=0 worse=0 better=0
// ALL OK, 189 function(s) have been successfully decompiled
